\section{Introduction}
\label{sec:introduction}

% When a static type checker locates a type error, the hope is that the type error accurately locates a problem that is blocking progress on the task at hand. 
% However, the reality is that the type error might incorrectly locate the problem, or locate a problem irrelevant to the task at hand. In all cases, the developer must fix all type errors before . These gaps in service can  persist for hours or days at a time, such as when a key type definition is 
% modified in a way that causes multiple errors to appear throughout a large program. 
% Until \emph{all} of these errors are fixed, it may be the case that \emph{none} of the changed code paths can be tested at run-time, 
% and many helpful language services are not fully functional \cite{HazelnutSNAPL}.

Modern programming environments provide developers with a collection of semantic services%
---for example, type hints, semantic navigation, semantic code completion, and automated refactorings---%
that require static reasoning about the type and binding structure of a program as it is being edited. 
The problem is that when the program being edited is ill-typed, 
these semantic services can become degraded or unavailable \cite{HazelnutSNAPL}. 
These gaps in service are not always transient. 
For example, a change to a type definition might result in type errors at dozens of use sites in a large program, which might take hours or days to resolve.

These gaps in service are fundamentally rooted in a definitional gap: a type system defined in a conventional way, 
e.g. in the tradition of the typed lambda calculus and its derivatives \cite{TaplBook,pfpl},
assigns meaning only to well-typed programs. 
If a type error appears \emph{anywhere}, the program is formally meaningless \emph{everywhere}.

This gap problem has prompted considerable practical interest in 
(1)~\textbf{type error localization}: mechanisms for identifying the location(s) in a program that may be at fault for a type error, and 
(2) \textbf{type error recovery}: mechanisms that allow the language server to optimistically recover from a localized type error 
and continue on to locate other errors and provide downstream semantic services, 
ideally at every location in the program and with minimal degradation in service.
Essentially all widely-used programming systems have some support for type error localization. 
When debugging type errors, developers have been observed to attend in particular to error locations presented in compiler error messages 
or directly in their editor, via error marks decorating the localized code.\todo{cite}
Many systems also attempt recovery of certain services in certain situations, discussed below.

However, type error localization and recovery mechanisms have developed idiosyncratically, 
often as folklore amongst language and tool implementors. 
Different type checkers or language servers \cite{langauge-servers,merlin}\todo{cite}, even for the same language, localize and recover from type errors in different ways, 
with little in the way of unifying theory of the sort that grounds the design of modern type systems themselves.

Consider, for example, the following program written in Hazel, a typed functional dialect of Elm \cite{elm} with 
support for local type inference, specified in the well-established bidirectional style \cite{pierce,hazelnut,BidirTyping}: 
\begin{lstlisting}[numbers=none]
let x = 
  if f(y) then 1 else true
in 
  x + 1
\end{lstlisting}
A type checker with no support for error localization or recovery---%
the sort often written by students in undergraduate courses---%
would simply report that this program is ill-typed, 
i.e. a type cannot be derived for it according to Hazel's type system. 

A more practical approach, and a common one even in production type checkers, 
is to localize the first error that causes local type inference to fail and emit an explanatory error message.
In this example, the system might report that the variable \li{f} located on Line 2 is unbound, then stop.

A language server with support for type error recovery would 
 be tasked with continuing past this first error.
 The general difficulty here is that there is now missing semantic information, namely the type of \li{f}, that 
 the bidirectional type system as specified 
 would appear to demand in order to proceed, here in order to determine which type the argument, \li{y}, is to be analyzed against.
 Intuitively, however, it seems that this type is actually \emph{unnecessary} to make an error localization decision about \li{y}: 
it is unbound, so a second error can be simultaneously localized despite the missing information.

To recover further, we might choose to also ignore the bidirectional type system's demand that the guard of the conditional be confirmed to be a boolean expression 
(because the type of \li{f(y)} is also unknown) 
and continue into its branches, observing that they have inconsistent types, \li{Int} and \li{Bool}. 
There are several ways to localize this inconsistency. 
One approach would be to assume, arbitrarily, that the first branch is correct, localizing the error to the second branch, or \emph{vice versa}.
(TODO: what does Elm do? what does OCaml do?)
Heuristics have been developed to help make choices like these less arbitrary, e.g. 
by observing recent editing history \todo{cite}, 
or training a machine learning model \todo{cite}. 
The other approach, which we take in this paper's language server for Hazel, is to localize the inconsistency to the conditional expression itself, as indicated in
the screenshot in Fig.~\ref{fig:hazel-intro-example}(b)\todo{figure}. 
This entirely avoids needing to heuristically decide which branch is correct: the problem is actually that the branch types differ.

This localization decision cannot be made in a vacuum, however; it affects how the system recovers as it proceeds into the let body, \li{x + 1}. 
If localization assumes that the \li{then} branch is correct, then \li{x : Int} and there is no error to report here.
If the \li{else} branch is chosen, then \li{x : Bool} and an error can be reported (though this error might mislead the programmer if this earlier localization guess was incorrect). 
If instead the inconsistency is localized to the conditional expression as a whole, as in our language server, then we again confront the problem of missing type information: 
\li{x} does not have a known type,
though it is known to be bound. 
There is no definitive problem here, based on the incomplete information available about \li{x}'s type, 
so we choose not to report an error in Hazel.

This informal exercise demonstrates that (1) localization choices can vary, particularly in regard to the extent to which they make \emph{ad hoc} guesses about intent;  
(2) when combined with error recovery, localization decisions have implications on downstream localization decisions; and 
(3) type error recovery mechanisms must be able to reason without complete knowledge about types and binding. 

This paper develops the first comprehensive {type-theoretic formulation} of type error localization and recovery, called the \emph{marked lambda calculus} (Sec.~\ref{sec:calculus}).
We bring together three individually well-studied ideas: (1) bidirectional typing, which specifies how type and binding information flows from 
type annotations to expressions, (2) gradual typing, which offers a principled approach for handling missing type information during recovery, and 
(3) non-empty holes, which operationalize type error localization by functioning as syntactic error marks, of the sort that a program editor would display on-screen.
These ideas were previously brought together in the Hazelnut calculus, but its account of type error localization and recovery was partial and tied integrally into its structure editor. 
We formally establish, with accompanying metatheory mechanized in Agda, that the marked lambda calculus has \emph{total error recovery}, i.e. that every syntactically well-formed program 
can be marked, i.e. errors can be localized. 



the key ideas behind bidirectional type error localization with gradual recovery by specifying 
the \emph{marked lambda calculus} (Sec.~\ref{sec:calculus}). 


Taking a formal approach has several benefits: it allows us to mechanically \emph{prove} that the system exhibits total error recovery, i.e. that recovery can never fail, 
it gives us the ability to precisely specify the type and binding structure of 


Start assuming a system with local type inference / bidirectional typing, marked lambda calculus(Give judgement forms right off the bat??) 
(Mention gradual typing here?)

We build on the foundation of the Hazelnut type system, which allows for local type inconsistencies to be placed within a non-empty hole, 
e.g. $1 + false$ is meaningless but $1 + \{false\}$ can be given type Num. In other words, the non-empty holes serves as a membrane around type inconsistencies, here between the expected type, Num, and the synthesized type, Bool. Problems:

1. does not handle every kind of error that can arise, e.g. inconsistent branch types, unbound variables, etc.

2. does not provide a general account for how to correctly place the non-empty holes -- in that paper, they assume that a structure editor will be used and show how the structure editor can determine whether a non-empty hole is needed at the cursor after an edit action, but edits that might cause non-local errors to appear are undefined. users can also manually mark these locations, similar to Agda's non-empty holes. (Examples?)

To solve both of these problems, we establish totality of marking -- we prove it to be total (and to insert only marks, without making any other changes), i.e. it must handle 
every possible syntactically well-formed program and thus every error. Mechanized in Agda.

Marking does not rely on a structure editor, so it is suitable as a foundational calculus for language servers supporting editors of any 
design, both text editors (with syntax error recovery, a well-studied topic that we consider outside of the scope of this paper) and structure editors. To support this claim, we have implemented the calculus in a version of Hazel built atop tylr, which features both a text editor with explicit syntax for holes (a la Agda, GHC, etc.) and a textual structure editor with syntax error recovery via automatic hole insertion. Maximal liveness guarantee! 

Additional foundational contribution, we have also defined two versions of Hazelnut that eliminate the undefined behavior just mentioned. Composed with marking, this solves the problem. Also briefly consider incremental remarking in the style of Hazelnut.

As we go, we'll discuss various localization design decisions that the language designer should consider when specifying the marked type system for their language. Overall, though, our work validates the folklore that systems that rely on local type inference tend to have an easier time deciding how to localize type errors (Pierce paper). Many modern languages feature local type inference, including .... 
However, non-local constraint-based type inference is also a common language feature, and it is known to substantially complicate error localization and recovery. 
Heuristic approaches based on ML-based approaches, weighting, etc.
In this paper, we consider an alternative approach to incorporating non-local constraints. Rather than ...

