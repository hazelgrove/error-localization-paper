
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% INTRO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%We attach unique identifiers to type holes, interpret them as type variables, and infer types for holes with Hindley-Milner \emph{type inference} \cite{MilnerInfer} based on unification \cite{RobinUnification}. The algorithm follows two standard steps, constraint generation and constraint solving by unification.

%The implementation inserts holes automatically, following the \Hazelnut edit action calculus, to guarantee that every editor state has some (possibly incomplete) type.

\section{Type Hole Inference}
\subsection{Introduction}
\label{sec:intro}
\emph{Bidirectional typing} and \emph{constraint-based type inference} are common approaches to deducing types for partially annotated programs. 
%\emph{Bidirectional typing} is a simple algorithmic system with type information propagating from the outside in \cite{BidirTyping}. 
This produces clear error messages at the cost of requiring explicit type annotations in certain situations, e.g. top-level functions. \emph{Type inference} allows programmers to omit most or all type annotations, but requires complex constraint solving for type checking, making it difficult for users to reason about types and producing complex error messages \cite{typeinferDif}.
This paper develops \emph{type hole inference}, which combines the benefits of bidirectional typing and type inference. Our approach takes the type system discussed for the marked lambda calculus and adds constraint solving as a layer on top to suggest type hole fillings, without making constraint solving necessary for typing. 

We define "solving" the constraints associated with a given type hole as the process of (1) identifying all of its possible type substitutions and (2) reporting the most informative substitutions to the user. If all possible substitutions are consistent with each other and do not elicit occurs check failure, the type hole is deemed \emph{solvable}.

\emph{Type hole inference} takes two steps: (1) use bidirectional typing for type checking, type synthesis and constraint generation; (2) solve the constraint set to infer types for type holes. In contrast to \emph{type inference}, our approach has the following features: (1) we separate type checking and constraint solving into two steps. The system only does type checking and triggers static errors at the first step; (2) expressions remain well-typed when the constraint solver can not find a solution for type variables, for instance when one type variable is equal to multiple types. Since  type variables may be unconstrained after unification, we can generalize those type holes by introducing polymorphism in the future work. 

Through the constraint solving layer of \emph{Type Hole Inference}, the user is given suggestions for type holes which are \textit{solvable}. In addition, \emph{type hole inference} provides debug information for \emph{unsolvable} type holes by presenting a \emph{PotentialTypeSet} containing all possible substitutions. When the user selects an \emph{unsolvable} type hole, rather than blaming one particular expression, the editor highlights the origins of all types that rendered it \emph{unsolvable}. Error localization feedback is visual and updated as edits occur, allowing the user to interactively repair their program.

\par{Contributions} The contributions of this paper are: (1) a new bidirectional typing system extended with type constraints in section ~\ref{sec:typinf}; (2) a type inference algorithm to handle type holes in section without failure upon hitting unsolvable constraints ~\ref{sec:infalg}.

\subsection{User Interaction}

Taking advantage of the interactive nature of live programming, rather than guessing sources of blame, we simply ask the user. \emph{Type hole inference} displays all possible sources of inconsistency and allows the user to identify which to blame. Once a user attempts to fix the program, the editor can display new errors as they arise. In this manner, the program can be iteratively and interactively repaired. \\

In Figure \ref{fig:editor_holes}, the user has written an incomplete program where the function $f$ is annotated with a type hole. Using type hole inference, the editor displays the inferred type for $f$.

\begin{figure}[H]
\includegraphics[width=10cm]{images/example_holes.png}
\includegraphics[width=10cm]{images/example_holes_CI.png}
\caption{incomplete program with partial hole filling suggestion}
\label{fig:editor_holes}
\end{figure}

Figure \ref{fig:editor_conflict} demonstrates visual feedback shown when a type hole is \textit{unsolvable}. The type hole is highlighted in red and surrounded by a dotted line, just like expressions wrapped in error holes. The user is informed via the Cursor Inspector that the type hole cannot be solved due to conflicting information from constraints.

\begin{figure}[H]
\includegraphics[width=10cm]{images/example_conflict.png}
\includegraphics[width=10cm]{images/example_conflict_CI.png}
\caption{user types '2' and error is localized to f's type hole}
\label{fig:editor_conflict}
\end{figure}

Figure \ref{fig:editor_ghost} illustrates a program which has a full solution for $f$'s type annotation. The user can then press the Enter key to accept the type hole suggestion, as shown in Figure \ref{fig:editor_complete}.

\begin{figure}[H]
\includegraphics[width=10cm]{images/example_ghost.png}
\includegraphics[width=10cm]{images/example_ghost_CI.png}
\caption{user removes '2' and types 'true' in the body of the else expression}
\label{fig:editor_ghost}
\end{figure}

\begin{figure}[H]
\includegraphics[width=10cm]{images/example_complete.png}
% \includegraphics[width=10cm]{images/example_complete_CI.png}
\caption{user accepts hole filling suggestion}
\label{fig:editor_complete}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TYPE SYSTEM %%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Type System}

\label{sec:typinf}
It is crucial that we be able to uniquely identify type holes within our constraint solving system. Doing so allows us to properly represent each type hole with distinct results during unification. Thus, we adjust the syntax of the marked lambda calculus slightly as depicted in Figure ~\ref{fig:adjusted-calculus-syntax}. We make three modifications to the existing calculus's syntax.:
\begin{enumerate}
    \item We add a unique id $u$ to all expression holes and user inserted type holes. This creates an avenue by we can to link type holes to their locus in the program. We assume that the assignment of ids to expression holes and user inserted type holes is taken care of by some action semantics on insertion of expression holes. 
    \item We add a \emph{type hole provenance}, drawn as a superscript such as $\tehole^p$. This allows the differentiation of type holes while describing the manner each type hole was generated.
    \item We add the empty expression hole. This change is purely for convenience and allows us to more effectively discuss different user edit states in our discussions of type hole inference.
\end{enumerate}

\begin{figure}[htbp]
  \[\begin{array}{rrcl}
    \Prov & \Provp & \Coloneqq & u \mid exp(u) \\
    \TMName  & \TMV  & \Coloneqq & \TUnknown^{p} \mid \TNum \mid \TBool \mid \TArrow{\TMV}{\TMV} \\
    \ECMName & \ECMV & \Coloneqq & x \mid \ECLam{x}{\TMV}{\ECMV} \mid \ECAp{\ECMV}{\ECMV}
                       \mid           \ECNumMV \mid \ECPlus{\ECMV}{\ECMV}
                       \mid           \ECTrue \mid \ECFalse \mid \ECIf{\ECMV}{\ECMV}{\ECMV} \\
             &       & \mid         & \ECUnbound{x}^u \mid \ECInconType{\ECMV}^u \mid \ECInconBr{\ECMV}{\ECMV}{\ECMV}^u \mid \EEHole^u
  \end{array}\]
  \caption{Adjusted syntax of the marked lambda calculus}
  \label{fig:adjusted-calculus-syntax}
\end{figure}

We turn to provenances for unique identification of type holes for two key benefits:
\begin{enumerate}
    \item Provenances allow each type hole to always have a concrete link to some type hole or expression hole that lies in the program. For instance, rather than identifying holes by an arbitrary id integer, the provenance $exp(3)$ tells us that this type hole was the result of synthesis on the expression hole with id 3.
    \item Provenances allow increased efficiency when compared to constantly generating fresh type hole ids, which would spawn far larger constraint graphs during constraint generation.
\end{enumerate}

\subsection{Constraint Generation}
Central to any type inference system is constraint generation. This topic has been widely explored in literature and is commonly completed alongside type checking (citation needed \todo{cite tapl}). We approach constraint generation from a notion of enforcing our expectations of various expressions and their types as we perform synthesis and analysis. Constraints can be accumulated across uses of bidirectional typing judgements after expressions have been marked to generate a final set of constraints. To facilitate this, we extend our previous judgement forms for the synthesis and analysis of matched expressions as follows:
\begin{center}
    $\ctxSynType{\ctx}{\ECMV}{\TMV} ~|~ C$ \hspace{3cm} $\ctxAnaType{\ctx}{\ECMV}{\TMV} ~|~ C$
\end{center}
Here, the set of constraints the judgement occurs under is captured in $C$. By redefining our judgements this way, we leverage the marked lambda calculus's type system to generate constraints inductively through bidirectional propagation. Below we discuss the constraint relation and a few interesting rules for constraint generation in detail.

\subsubsection{The Constraint Relation}
In some sense, $C$ represents all expected consistencies in a program. However, the constraints within $C$ are not the same as consistency, nor are they the same as equality. Rather, we represent constraints as a new relation, $\tau_1 \approx \tau_2$. If $\tau_1 \approx \tau_2$, $\tau_1$ and $\tau_2$ are \textit{allegedly} the same type, and share the same solution. This relation only exhibits transitivity across type holes and types containing type holes. We refer to such types as "incomplete" types following the definitions laid out in ~\cite{HazelnutPOPL}. "Complete" types, on the other hand, are types that contain no type holes. 

% As an example of why transitivity shouldn't be permitted across complete types, consider the constraint set $C_{ex1} = \{ \tehole^{1} \approx \tnum, ~ \tnum \approx~ \tehole^{2}\}$. Here, even though both $\tehole^{1}$ and $\tehole^{2}$ are constrained to $\tnum$, it is not that case that $\tehole^1 \approx \tehole^2$. 
Suppose we defined constraints with transitivity across complete types. In such a world, we may end up with the program below:
\begin{center}
\includegraphics[width=5cm]{images/constraint_gen_bad_example.png}
\end{center}
This program can be associated with the constraints $C = \{ \tehole^{x} \approx \tnum, \tehole^{y} \approx \tnum, \tehole^{y} \approx \mathtt{string} \}$ based on the usage of the $+$ operator and binding of $"hello"$ to $y$. Since the editor treats constraints as transitive across complete types, it finds that $\tehole^{x} \approx \tehole^{y}$ given $\tehole^{x} \approx \tnum$ and $\tehole^{y} \approx \tnum$. Consequently, the two type holes have conflicting type hole fillings of $\tnum$ and $\mathtt{string}$. This behavior is undersirable, as $\tehole^x$ was never directly associated with the string $"hello"$ and should be solved as $\tnum$.

\subsubsection{Intuition behind constraints}
As an example of the constraint generation process, let us consider the program illustrated in Figure \ref{fig:editor_ghost}. We define an equivalent marked expression $\ECMV_{ex}$ below where the let expression has been replaced with an annotated lambda applied to the body of the let:
$$\ECMV_{ex} \equiv \ECAp{(\ECLam{f}{\TUnknown^1}{~~\ECIf{\EEHole^2~}{~(\ECAp{f}{\underline{2}})}{~\EEHole^3}})}{~~\EEHole^0}$$
What constraints might we expect this expression to generate? In this program, we expect that the annotation of the lambda is consistent with the type of its argument, $\EEHole^0$. This notion might generate the constraint $\{ \TUnknown^1 \approx \TUnknown^{exp(0)}\}$. We might further notice that we expect both branches of the if expressions to synthesize consistent types. But what is the type of $\ECAp{f}{\underline{2}}$? Previously, we might have argued that it would simply be $\TUnknown$; however, now we must ask exactly \emph{which} type hole this application synthesizes and determine its provenance. In order to further understand these questions, let us explore a more formal definition of constraint generation before revisiting this example.

\subsubsection{Subsumption Constraints}
As discussed earlier, constraints constitute a series of expectations for what different types should be. One key mechanism by which we facilitate our accumulation of these expectations is analysis. Indeed, when we expect something should have a type \TMV, we commonly analyze it against that type. As a classic example of this, consider subsumption. 

Suppose we have a marked expression \ECMV~ that satisfies the judgement \ctxSynType{\ctx}{\ECMV}{\TMV'} for some context \ctx. If we attempt to analyze \ECMV~ against the type $\tau$, we require, or put another way, we expect, that \consistent{\TMV}{\TMV'}. In order to more concretely track this expectation as a constraint, we extend the rule MASubsume as follows so that it generates the constraint $\tau \approx \tau'$:
\begin{mathpar}
  \judgment{
    \ctxSynType{\ctx}{\ECMV}{\TMV'} ~|~ C \\
    \consistent{\TMV}{\TMV'} \\
    \subsumable{\ECMV}
  }{
    \ctxAnaType{\ctx}{\ECMV}{\TMV} ~|~ C \cup \{ \TMV \approx \TMV' \}
  }{MASubsume-C}
\end{mathpar}
Notice that we also accumulate constraints generated in each premise in our conclusion.

One key question is how one should manage constraints whenever marked expressions are wrapped in holes. Should expectations of types pass through the hole membrane and render expressions inside unsolvable? On a similar tack, should a program inside some hole membrane seep out and affect the rest of the program? We assert that the answer to both of these questions is no. Nonempty holes should act as quarantines that allow the programmer to reason as if expressions inside them are unaffected by and do not affect the program around them.

With this guiding principle in hand, let us approach constraint generation for subsumption when \inconsistent{\TMV}{\TMV'} by extending MAInconsistentTypes:
\begin{mathpar}
  \judgment{
    \ctxSynType{\ctx}{\ECMV}{\TMV'} ~|~ C  \\
    \inconsistent{\TMV}{\TMV'} \\
    \subsumable{\ECMV}
  }{
    \ctxAnaType{\ctx}{\ECInconType{\ECMV}^u}{\TMV} ~|~ C \cup \{ \TMV \approx \TUnknown^{exp(u)} \}
  }{MAInconsistentTypes-C}
\end{mathpar}
Here we accumulate constraints from our premises just as before. However, instead of expecting that the type of \ECMV~ be the consistent with the type $\tau$ when this is clearly impossible, we prevent any conflicts that may arise from $\tau$ reaching beyond our type hole membrane. Instead, we enforce that the hole surrounding \ECMV~ synthesize a type consistent with $\tau$.

\subsubsection{If Expressions and Their Constraints}
Expectations for the result of typechecking on expressions is not limited to analysis. Indeed, there are multiple cases where we hold expectations for the types of our expressions in synthesis as well. As a simple example, consider if expressions. We expect that both branches have consistent types and assess this implicitly by attempting to compute their lower bound. This leads to the following constraint generating rule for if expression synthesis where we simply accumulate constraints and require that $\TMV_1 \approx \TMV_2$:

\begin{mathpar}
  \judgment{
    \ctxAnaType{\ctx}{\ECMV_1}{\TBool} ~|~ C_1  \\
    \ctxSynType{\ctx}{\ECMV_2}{\TMV_1} ~|~ C_2 \\
    \ctxSynType{\ctx}{\ECMV_3}{\TMV_2} ~|~ C_3
  }{
    \ctxSynType{\ctx}{\ECIf{\ECMV_1}{\ECMV_2}{\ECMV_3}}{\TJoin{\TMV_1}{\TMV_2}} ~|~ C_1 \cup C_2 \cup C_3 \cup \{ \TMV_1 \approx \TMV_2 \}
  }{MSIf-C}
\end{mathpar} 

Our logic is somewhat trickier when the branches of an if expression have no lower bound, causing it to be wrapped in a marked hole. However, we can still use the same principles leveraged for MSInconsistentTypes-C to our advantage. Inconsistency among branches should be considered an error that lies \emph{within} the hole membrane surrounding our marked expression. Consequently, we constrain $\TMV_1 \approx \TMV_2$ as before and do not consider the type our our hole membrane, $\TUnknown^{exp(u)}$, in the constraints:

\begin{mathpar}
  \judgment{
    \ctxAnaType{\ctx}{\ECMV_1}{\TBool} ~|~ C_1 \\
    \ctxSynType{\ctx}{\ECMV_2}{\TMV_1} ~|~ C_2 \\
    \ctxSynType{\ctx}{\ECMV_3}{\TMV_2} ~|~ C_3 \\
    \inconsistent{\TMV_1}{\TMV_2}
  }{
    \ctxSynType{\ctx}{\ECInconBr{\ECMV_1}{\ECMV_2}{\ECMV_3}^u}{\TUnknown^{exp(u)}} ~|~ C_1 \cup C_2 \cup C_3 \cup \{ \TMV_1 \approx \TMV_2 \}
  }{MSInconsistentBranches-C}
\end{mathpar}

For both of the above rules on if expressions, we assume that the definition of $\TJoin{\TMV_1}{\TMV_2}$ has been adjusted to accept type holes with provenances where we arbitrarily decide that $\TJoin{\TUnknown^{p1}}{\TUnknown^{p2}} = \TUnknown^{p1}$.

\subsubsection{Matched Arrow Constraints}
When we generate a matched arrow form for a type hole, we are expecting that the original type hole be equal to the arrow type outputted by the judgement. Consequently, we find that matched arrow judgements must also accumulate constraints. Thus, we must adjust the form of our matched arrow judgement to be of the form $\matchedArrow{\TMV}{\TMV_1}{\TMV_2} ~|~ C$.

However, one key question that remains is which provenance to assign the holes outputted by the matched arrow judgement. If we were to simply generate fresh holes ids, they would have no concrete link to the program. To resolve this, we introduce matched arrow provenances, which give information on a type hole's creation while detailing which type hole it spawned from:
\begin{center}
    $\arraycolsep=4pt\begin{array}{lll}
    \Prov~~ p & ::= & 
        ... ~\vert~ 
        \rightarrow_L(\Provp) \mid \rightarrow_R(\Provp)
        \\
    \end{array}$
\end{center}

Using this, the constraint generating form of TMAHole can constrain the original hole to its matched counterpart while assigning matched arrow provenances to each newly created type hole:

\begin{mathpar}
\judgment{ }{
  \matchedArrow{\TUnknown^p}{\TUnknown^{\rightarrow_L(p)}}{\TUnknown^{\rightarrow_R(p)}} ~|~ \{ \TUnknown^p \approx \tarr{\TUnknown^{\rightarrow_L(p)}}{\TUnknown^{\rightarrow_R(p)}} \}
}{TMAHole-C}
\end{mathpar}

\subsubsection{Lambda Expressions and Their Constraints}
With this new definition of matched arrow in hand, we can approach lambdas. Our rule for analysis of annotated lambdas when no local errors are present is similar asserts that the annotation \TMV~ be consistent with the input type of the argument to analysis:

\begin{mathpar}
  \judgment{
    \matchedArrow{\TMV_3}{\TMV_1}{\TMV_2} ~|~ C_1\\
    \consistent{\TMV}{\TMV_1} \\
    \ctxAnaType{\extendCtx{\ctx}{x}{\TMV}}{\ECMV}{\TMV_2} ~|~ C_2
  }{
    \ctxAnaType{\ctx}{\ECLam{x}{\TMV}{\ECMV}}{\TMV_3} ~|~ C_1 \cup C_2 \cup \{ \TMV \approx \TMV_1 \}
  }{MALam1-C}
\end{mathpar}

Our rules for the remaining two lambda analysis cases where the lambda expression is wrapped in a marked hole are trickier. Let us begin by assessing the case where the analyzed type has no matched arrow form. In such cases, we previously analyzed the body of the lambda against the unknown type to ensure its validity. However, which unknown type are we analyzing the body against? As discussed earlier, performing analysis imparts the expectation that the type of the expression is consistent with the argument of analysis. If we were to simply analyze against the type of the hole membrane we use to surround the marked lambda, we'd impart the expectation that the lambda's body is consistent with the hole membrane itself. This would subvert our goal of separating the program outside the hole with that inside! In fact, any hole we choose would impart some invalid expectation with respect to the goals we've outlined. Consequently, we introduce the anonymous type hole: this type hole is represented by the provenance $anon$ and will have its constraints ignored by the constraint solver when we later explore unification.
\begin{center}
    $\arraycolsep=4pt\begin{array}{lll}
    \Prov~~ p & ::= & 
        ... ~\vert~ 
        anon
        \\
    \end{array}$
\end{center}
Using this type hole, we can analyze the lambda's body against an unknown type without linking it spuriously to some other type hole:

\begin{mathpar}
  \judgment{
    \notMatchedArrow{\TMV_3} \\
    \ctxAnaType{\extendCtx{\ctx}{x}{\TMV}}{\ECMV}{\TUnknown^{anon}} ~|~ C
  }{
    \ctxAnaType{\ctx}{\ECInconType{\ECLam{x}{\TMV}{\ECMV}}^u}{\TMV_3} ~|~ C \cup \{ \TUnknown^{exp(u)} \approx \TMV_3 \}
  }{MALam2-C}

  \judgment{
    \matchedArrow{\TMV_3}{\TMV_1}{\TMV_2} ~|~ C_1\\
    \inconsistent{\TMV}{\TMV_1} \\\\
    \ctxAnaType{\extendCtx{\ctx}{x}{\TMV}}{\ECMV}{\TMV_2} ~|~ C_2
  }{
    \ctxAnaType{\ctx}{\ECInconType{\ECLam{x}{\TMV}{\ECMV}}^u}{\TMV_3} ~|~ C_1 \cup C_2 \cup \{ \TUnknown^{exp(u)} \approx \TMV_3 \}
  }{MALam3-C}
\end{mathpar}
Note that the conclusion of this rule adds the constraint $\{ \TUnknown^{exp(u)} \approx \TMV_3 \}$. The argument of analysis $\TMV_3$ constitutes an expectation of types from outside the hole surrounding our lambda. Consequently, rather than allowing it to influence the program inside the hole, we simply constrain $\TMV_3$ to the hole's type, $?^{exp(u)}$. The rule for analysis of annotated lambdas when the our annotation is inconsistent with the input type of our analyzed type is similarly defined and we consequently omit any in depth discussion of its properties.


\subsubsection{Applications and Their Constraints}
This brings us at last to the application of lambdas. When the function position expression lacks a match arrow form, we wrap it in a marked expression hole and proceed as if we had called matched arrow on the hole. To facilitate this, the argument expression must be analyzed against $\TUnknown^{\rightarrow_L{u}}$ and we must return $\TUnknown^{\rightarrow_R{u}}$ as the result of synthesis. 


\begin{mathpar}
  \judgment{
    \ctxSynType{\ctx}{\ECMV_1}{\TMV} ~|~ C_1 \\
    \notMatchedArrow{\TMV} \\
    \ctxAnaType{\ctx}{\ECMV_2}{\TUnknown^{\rightarrow_{L}(exp(u))}} ~|~ C_2
  }{
    \ctxSynType{\ctx}{\ECApNonMatched{\ECMV_1}{\ECMV_2}}{\TUnknown^{\rightarrow_{R}(exp(u))}} ~|~ C_1 \cup C_2 \cup \{ \TUnknown^{exp(u)} \approx \tarr{\TUnknown^{\rightarrow_L(exp(u))}}{\TUnknown^{\rightarrow_R(exp(u))}}\}
  }{MSAp2-C}
\end{mathpar}

\subsubsection{Other Constraint Generating Rules}
The remaining rules are all axiomatic and need not accumulate any constraints or simply accumulate constraints from each of their premises as done above. As a result, the are somewhat repetitive and are consequently left to the supplemental material in Appendix B.

\subsubsection{An Example of Constraint Generation}
Now that we have defined a formal approach to constraint generation, let us revisit $\ECMV_{ex}$ and try once again to identify its constraints:
$$\ECMV_{ex} \equiv \ECAp{(\ECLam{f}{\TUnknown^1}{~~\ECIf{\EEHole^2~}{~(\ECAp{f}{\underline{2}})}{~\EEHole^3}})}{~~\EEHole^0}$$
Let us begin with the body of the lambda, $\ECIf{\EEHole^2~}{~(\ECAp{f}{\underline{2}})}{~\EEHole^3}$. Based on the rule MSIf-C, we must analyze our scrutinee, $\EEHole^2$ against $\tbool$. This triggers subsumption, yielding the constraint $\{ \TUnknown^{exp(2)} \approx \tbool \}$. Next, we must synthesize the types of our branches: $\ECAp{f}{\underline{2}}$ and $\EEHole^3$. Synthesis of $\EEHole^3$ is simple: via the axiom MSEHole-C defined in appendix B, it synthesizes $\TUnknown^{exp(3)}$ with no constraints.

Syntheis of $\ECAp{f}{\underline{2}}$ is more complex. Following MSAp1-C, we attempt to take the matched arrow of $\TUnknown^1$, yielding the constraint $\{ \TUnknown^1 \approx \tarr{\TUnknown^{\rightarrow_L(1)}}{\TUnknown^{\rightarrow_R(1)}} \}$. Next, we analyze the argument $\underline{2}$ against the input type of $f$, $\TUnknown^{\rightarrow_L(1)}$. This triggers subsumption, which yields the constraint $\{ \TUnknown^{\rightarrow_L(1)} \approx \tnum \}$. With these results in hand, we can determine that the result of synthesis on  $\ECAp{f}{\underline{2}}$ is $\TUnknown^{\rightarrow_R(1)}$ with constraint set $\{ \TUnknown^1 \approx \tarr{\TUnknown^{\rightarrow_L(1)}}{\TUnknown^{\rightarrow_R(1)}},  \TUnknown^{\rightarrow_L(1)} \approx \tnum \}$.

Combining these results and constraining types of both branches to each other, we find that $\ECIf{\EEHole^2~}{~(\ECAp{f}{\underline{2}})}{\EEHole^3}$ synthesizes type $\TUnknown^{\rightarrow_R(1)}$ with constraint set $\{ \TUnknown^{exp(2)} \approx \tbool, \TUnknown^1 \approx \tarr{\TUnknown^{\rightarrow_L(1)}}{\TUnknown^{\rightarrow_R(1)}},  \TUnknown^{\rightarrow_L(1)} \approx \tnum,  \TUnknown^{\rightarrow_R(1)} \approx \TUnknown^{exp(3)}\}$. 

Synthesis of our lambda expression yields no additional constraints and has the type $\tarr{\TUnknown^1}{\TUnknown^{\rightarrow_L(1)}}$. Application of the lambda on $\EEHole^0$ yields the constraint $\{ \TUnknown^{exp(0)} \approx \TUnknown^{1} \}$ due to subsumption and yields the final type  $\TUnknown^{\rightarrow_R(1)}$. Thus, we find that $\ctxSynType{\cdot}{\ECMV_{ex}}{\TUnknown^{\rightarrow_R(1)}} ~|~ C_{ex1}$ where 
$$C_{ex1} = \{ \TUnknown^{exp(2)} \approx \tbool, \TUnknown^1 \approx \tarr{\TUnknown^{\rightarrow_L(1)}}{\TUnknown^{\rightarrow_R(1)}},  \TUnknown^{\rightarrow_L(1)} \approx \tnum, \TUnknown^{exp(0)} \approx \TUnknown^{1}, \TUnknown^{\rightarrow_R(1)} \approx \TUnknown^{exp(3)} \}$$

% \begin{figure}[h!]
% \vspace{-3px} 
%     \begin{multicols}{2}
%       \fbox{$\consexptyp{\Gamma}{e}{\tau}{C}$}~~\text{$e$ synthesizes $\tau$}\hfill
%     \begin{subequations}
%     \begin{equation}\label{rule:syn-var}
%         \inferrule[]{ }{
%             \consexptyp{\Gamma, x : \tau}{x}{\tau}{\econs}
%           }
%     \end{equation}
%     \begin{equation}\label{rule:syn-num}
%         \inferrule[]{ }{
%             \consexptyp{\Gamma}{\hnum{n}}{\tnum}{\econs}
%           }
%     \end{equation}
%     \begin{equation}\label{rule:syn-plus}
%         \inferrule[]{
%             \ana{\Gamma}{e_1}{\tnum}{C_1} \\
%             \ana{\Gamma}{e_2}{\tnum}{C_2}
%           }{
%             \consexptyp{\Gamma}{(e_1 + e_2)}{\tnum}{C_1 \cup C_2}
%           }
%     \end{equation}
%     \begin{equation}
%         \inferrule[]{
%             \ananc{\Gamma}{e_1}{\tnum}\\
%             \ananc{\Gamma}{e_2}{\tnum}
%           }{
%             \consexptypnc{\Gamma}{(e_1 + e_2)}{\tnum}
%           }
%     \end{equation}
%     \begin{equation}\label{rule:syn-asc}
%         \inferrule[]{
%             \ana{\Gamma}{e}{\tau}{C}
%           }{
%             \consexptyp{\Gamma}{(e : \tau)}{\tau}{C}
%           }
%     \end{equation}
%     \begin{equation}\label{rule:syn-ehole}
%         \inferrule[]{ }{
%             \consexptyp{\Gamma}{\llparenthesiscolor \rrparenthesiscolor^n}{\tehole^n}{\econs}
%           }
%     \end{equation}
%     \begin{equation}\label{rule:syn-hole}
%         \inferrule[]{
%             \consexptyp{\Gamma}{e}{\tau}{C}
%            }{
%              \consexptyp{\Gamma}{\llparenthesiscolor e \rrparenthesiscolor^n}{\tehole^n}{C}
%            }
%     \end{equation}
%     \begin{equation}\label{rule:syn-lamann}
%         \inferrule[]{
%           \consexptyp{\Gamma, x : \tau_{in}}{e}{\tau_{out}}{C}
%         }{
%           \consexptyp{\Gamma}{\lamfunc{x:\tau_{in}}{e}}{\tarr{\tau_{in}}{\tau_{out}}}{C}
%         }
%     \end{equation}
%     \begin{equation}\label{rule:syn-ap}
%       \inferrule[]{
%           \consexptyp{\Gamma}{e_1}{\tau_1}{C_1} \\
%           \tau_1 \typearrow \tarr{\tau_{in}}{\tau_{out}} \addcons{C_2} \\
%           \ana{\Gamma}{e_2}{\tau_{in}}{C_3}
%         }{
%           \consexptyp{\Gamma}{\hap{e_1}{e_2}}{\tau_{out}} { C_1 \cup C_2 \cup C_3}
%         }
%   \end{equation}
%     \begin{equation}\label{rule:syn-if}
%         \inferrule[]{
%             \ana{\Gamma}{e_1}{\TBool}{C_1} \\
%             \consexptyp{\Gamma}{e_2}{\tau_1}{C_2} \\
%             \consexptyp{\Gamma}{e_3}{\tau_2}{C_3}
%         }{
%             \consexptyp{\Gamma}{\EIf{e_1}{e_2}{e_3}}{\TJoin{\tau_1}{\tau_2}}{C_1 \cup C_2 \cup C_3 \cup \{\ \tau_1 \approx \tau_2 \}}
%         }
%     \end{equation}
%     \end{subequations}
%     \vspace{3px}\fbox{$\ana{\Gamma}{e}{\tau} {C}$}~~\text{$e$ analyzes against $\tau$}\hfill
%     \begin{subequations}
%     \begin{equation}\label{rule:ana-subsume}
%         \inferrule[]{
%           \consexptyp{\Gamma}{e}{\tau'}{C_1} \\
%           \tau \sim \tau'
%         }{
%           \ana{\Gamma}{e}{\tau}{C_1 \cup \{ \tau \approx \tau' \}}
%         }
%     \end{equation}
%     \begin{equation}\label{rule:ana-lam}
%         \inferrule[]{
%             \tau \typearrow \tarr{\tau_{in}}{\tau_{out}} \addcons{C_1} \\
%              \ana{\Gamma, x : \tau_{in}}{e}{\tau_{out}}{C_2}
%            }{
%              \ana{\Gamma}{\lamfunc{x}{e}}{\tau}{C_1 \cup C_2}
%            }
%     \end{equation}
%     \begin{equation}\label{rule:ana-lamann}
%         \inferrule[]{
%          \tau \typearrow \tarr{\tau_{in}}{\tau_{out}} \addcons{C_1} \\
%           \ana{\Gamma, x : \tau'_{in}}{e}{\tau_{out}}{C_2} \\
%           \tau_{in} \sim \tau'_{in}
%         }{
%           \ana{\Gamma}{\lamfunc{x:\tau'_{in}}{e}}{\tau}{C_1 \cup C_2 \cup \{ \tau_{in} \approx \tau'_{in} \}}
%         }
%     \end{equation}
%     \end{subequations}
%   \end{multicols}
%   \hrule
%   \caption{H-type synthesis and analysis.}
%   \label{fig:ana-syn}
%   \vspace{-10px}
% \end{figure}

% \begin{figure}[h!]
%     \fbox{$\tau \typearrow \tarr{\tau_{in}}{\tau_{out}} \addcons{C}$}~~\text{$\tau$ has matching arrow type $\tarr{\tau_{in}}{\tau_{out}}$}\hfill
%     \begin{subequations}\label{eqns:matcharrow}
%       \begin{minipage}{0.43\linewidth}
%         \begin{equation}
%           \inferrule[]{ }{
%             \tarr{\tau_{in}}{\tau_{out}} \typearrow \tarr{\tau_{in}}{\tau_{out}} \addcons{\econs}
%           }
%         \end{equation}
%         \end{minipage}
%         \begin{minipage}{0.55\linewidth}
%         \begin{equation}
%           \inferrule[]{ }{
%              \tehole^p \typearrow \tarr{\tehole^{\rightarrow_{L}(p)}}{\tehole^{\rightarrow_{R}(p)}} \addcons{\{ \tehole^p \approx \tarr{\tehole^{\rightarrow_{L}(p)}}{\tehole^{\rightarrow_{R}(p)}} \} }
%            }
%         \end{equation}
%         \end{minipage}

%     \end{subequations}
%     \hrule
%     \caption{Matched arrow types.}
%     \label{fig:match-arrow-typ} 
%     \vspace{-2px} 
%   \end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% INFERENCE ALGORITHM %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usetikzlibrary{positioning,calc}

\subsection{Constraint Solving}
The problem of inferring types from constraints has been widely explored in the literature. In the spirit of Hazel, which allows users to program with holes and even run incomplete programs, it would be beneficial to provide holistic type-related feedback for all edit states. Moreover, we approach type inference with the key goal of representing all potential type fillings for type holes, regardless of any conflicts that may arise during unification.

In order to do this, we begin with a simpler problem: representing our constraints as an undirected graph. We'd like to construct our graph such that if the node associated with type hole $\TUnknown^{p_2}$ can be reached from $\TUnknown^{p_1}$, it must be the case that $\TUnknown^{p_1} \approx \TUnknown^{p_2}$. Once we have a graph of all constraints, the problem of identifying potential types to suggest for any type hole in the program can be boiled down to that of identifying our graph's connected components. Put another way, if we want to find the potential types that may be used to fill some type hole, all we need to do is find all nodes that can be reached from its node in the constraint graph.


\subsubsection{Approaches to Constructing Constraint Graphs}
When constructing a graph of our constraints, our first inclination  might be to allow all types found in our constraints to act as nodes in our graph. We could then create a traversable edge between nodes for every constraint. However, such a choice prevents pairs that are reachable from one another from always being related via the constraint relation. To see why, recall that the constraint relation is only transitive across incomplete types (those containing at least one type hole). Since edges can be traversed transitively, we cannot have traversable edges between all types represented in constraints. Rather, only incomplete types can have traversable edges. Conversely, complete types should be reachable only by incomplete types that have been directly constrained to them. 

To simplify this observation, we assert that only incomplete types can be nodes in our graph. We refer to edges connecting incomplete types as \emph{traversable edges} which we draw as solid lines. Edges linking to complete types will be represented via \emph{solution edges}, which we draw as dashed lines. These edges can only be used to travel into complete types and can never be used to travel out. As a result, they simply influence the solutions possible for the nodes that can reach into them via some \emph{solution edge}. As an example of this, consider Figure \ref{fig:ex1ex2graphs}. 
\begin{figure}[htb!]
\centering
\begin{subfigure}{.49\textwidth}
  \centering
      \begin{tikzpicture}
      [scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
      \node[rectangle,minimum size=0.85cm] (n1) at (3,3) {$\tehole^{1}$};
      \node[rectangle,minimum size=0.85cm] (n2) at (1,3)  {$\tehole^{2}$};
      \node[minimum size=0.85cm] (i) at (3,1)  {$\tnum$};
    
      \foreach \from/\to in {n1/n2}
        \draw (\from) -- (\to);
       \foreach \from/\to in {n1/i}
        \draw[dashed] (\from) -- (\to);
    
    \end{tikzpicture}
  \caption{Graph of $C_{ex2} = \{ \tehole^{1} \approx \tnum, ~ \tehole^{1} \approx~ \tehole^{2}\}$}
  \label{fig:reachable-tag}
\end{subfigure}
\begin{subfigure}{.49\textwidth}
  \centering
  \begin{tikzpicture}
  [scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
  \node[rectangle,minimum size=0.85cm] (n1) at (2,3) {$\tehole^{1}$};
  \node[rectangle,minimum size=0.85cm] (n2) at (4,3)  {$\tehole^{2}$};
  \node[minimum size=0.85cm] (i1) at (4,1)  {$\tnum$};
  \node[minimum size=0.85cm] (i2) at (2,1)  {$\tnum$};
  \node[minimum size=0.85cm] (i3) at (0,3)  {$\tbool$};

   \foreach \from/\to in {n1/i3, n1/i2, n2/i1}
    \draw[dashed] (\from) -- (\to);

\end{tikzpicture}
  \caption{Graph of $C_{ex3} = \{ \tehole^1 \approx \tnum, ~ \tehole^1 \approx \tbool, ~ \tnum \approx~ \tehole^2\}$}
  \label{fig:disjoint-nodes}
\end{subfigure}
\caption{Sample constraint graphs of ground types}
\label{fig:ex1ex2graphs}
\end{figure}

Figure \ref{fig:reachable-tag} illustrates a set of constraints $C_{ex2} = \{ \tehole^{1} \approx \tnum, ~ \tehole^{1} \approx~ \tehole^{2}\}$ where all nodes can be solved as $\tnum$ by travelling into $\tnum$ through $\tehole^1$, resulting in it having a single connected component. On the other hand, figure  \ref{fig:disjoint-nodes} illustrates an example set of constraints $C_{ex3} = \{ \tehole^1 \approx \tnum, ~ \tehole^1 \approx \tbool, ~ \tnum \approx~ \tehole^2\}$ where $\tnum$ is travelled into by two separate incomplete types, but cannot be used to connect them. Consequently, it contains two connected components.

% Constructing a graph of type nodes and adding edges between them has an important caveat: Only $\tehole^{p}$ or types containing at least one $\tehole^{p}$ are added to the graph as nodes. See Figure \ref{fig:ex1ex2graphs} for an illustration. In part (a) of Figure \ref{fig:ex1ex2graphs}, $\tehole^{1}$ and $\tehole^{2}$ are nodes in the graph \textit{linked} by a solid edge, and $\tnum$ is not. Instead, $\tnum$ is more like a \textit{tag} adding additional type information to $\tehole^{1}$. Hence, we use a dotted edge in the illustration to represent this distinction. Since $\tnum$ is constrained to $\tehole^{1}$, the solver can infer using union-find that $\tehole^{2}$ must also contain $\tnum$ in its \textit{PotentialTypeSet}, because $\tehole^{1}$ and $\tehole^{2}$ are part of the same connected component. By contrast, in part (b), $\tehole^{1}$ and $\tehole^{2}$ are both \textit{tagged} with $\tnum$, but because they are not part of the same connected component, the solver will not infer that they share the same \textit{PotentialTypeSet}. Consequently, the solver will correctly not infer that $\tehole^2$ contains $\tbool$ in its \textit{PotentialTypeSet}.

Upon encountering a constraint between two arrow types, we can generate two new constraints on-the-fly: one between the left children of the arrows, and one between the right children of the arrows. For example, given the constraint set $C_{ex4} = \{ \tarr{\tehole^1}{\tehole^2} \approx \tarr{\tehole^3}{\tnum} \}$, we generate the constraints $\tehole^1 \approx \tehole^3$ and $\tehole^2 \approx \tnum$. These constraints can then be used to render the graph depicted in Figure \ref{fig:arrowgraph}.

\begin{figure}[htb!]
\centering
\begin{subfigure}{.49\textwidth}
        \centering
      \begin{tikzpicture}[remember picture,
  inner/.style={rectangle,draw=blue!50,fill=blue!20,thick,inner sep=3pt,minimum size=0.85cm},
  innercirc/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=3pt,minimum size=0.85cm},
  outer/.style={draw=green,fill=green!20,thick,inner sep=10pt}
  ]
  \node[outer,draw=green] (A) {
    \shortstack{
        $Arrow$\\
        \begin{tikzpicture}
          \node [inner] (n1)  {$\tehole^{1}$};
          \node [inner,right=of n1] (n2) {$\tehole^{2}$};
          % \draw[red,thick,->] (n1) -- (n2);
        \end{tikzpicture}
    }
  };
  \node[outer,draw=green,below=of A] (B) {
    \shortstack{
        $Arrow$\\
        \begin{tikzpicture}
          \node [inner] (n3)  {$\tehole^{3}$};
          \node [innercirc,right=of n3] (i) {$\tnum$};
          % \draw[red,thick,->] (n3) -- (i);
        \end{tikzpicture}
    }
  };
  \draw (n1) -- (n3);
  \draw[dashed] (n2) -- (i);
   \draw[thick] (A) -- (B);
\end{tikzpicture}
\caption{Expanded constraint graph of\\ $C_{ex3} = \{ \tarr{\tehole^1}{\tehole^2} \approx \tarr{\tehole^3}{\tnum} \}$}
\label{fig:arrowgraph}
\end{subfigure}
\begin{subfigure}{.49\textwidth}
  \centering
  \begin{tikzpicture}[remember picture,
  tag/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=3pt,minimum size=0.85cm},
  holey/.style={rectangle,draw=green!50,fill=green!20,thick,inner sep=5pt,minimum size=0.85cm},
  ]
  \node[holey] (hole1) {$\tehole^1$};
  \node[holey, right=of hole1] (hole0) {$\tehole^0$};
  \node[holey, below=of hole1] (Arrow) {
    \shortstack{
        $Arrow$\\
        \begin{tikzpicture}
          \node [holey] (holeL1)  {$\tehole^{\rightarrow_{L(1)}}$};
          \node [holey, right=of holeL1] (holeR1) {$\tehole^{\rightarrow_{R(1)}}$};
        \end{tikzpicture}
    }
  };
 \node[tag, below=of holeL1] (num) {$\tnum$};
 \node[holey, below=of holeR1] (hole3) {$\tehole^3$};
 \node[holey, right=of holeR1] (hole2) {$\tehole^2$};
 \node[tag, below=of hole2] (bool) {$\tbool$};
  \draw[draw=red] (hole1) -- (hole0);
  \draw[draw=red] (hole1) -- (Arrow);
  \draw[dashed] (num) -- (holeL1);
  \draw (hole3) -- (holeR1);
  \draw[dashed] (bool) -- (hole2);
\end{tikzpicture}
\caption{Constraint graph of\\ 
$C_{ex1} = \{ \tarr{\tehole^1}{\tehole^2} \approx \tarr{\tehole^3}{\tnum} \}$}
\label{fig:C-ex-graph-traversal}
\end{subfigure}
\caption{Sample constraint graphs including binary types}
\label{fig:ex1ex2graphs}
\end{figure}

% \begin{figure}[h!]
% \centering
% \begin{tikzpicture}[remember picture,
%   inner/.style={rectangle,draw=blue!50,fill=blue!20,thick,inner sep=3pt,minimum size=0.85cm},
%   innercirc/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=3pt,minimum size=0.85cm},
%   outer/.style={draw=green,fill=green!20,thick,inner sep=10pt}
%   ]
%   \node[outer,draw=green] (A) {
%     \shortstack{
%         $Arrow$\\
%         \begin{tikzpicture}
%           \node [inner] (n1)  {$\tehole^{1}$};
%           \node [inner,right=of n1] (n2) {$\tehole^{2}$};
%           % \draw[red,thick,->] (n1) -- (n2);
%         \end{tikzpicture}
%     }
%   };
%   \node[outer,draw=green,below=of A] (B) {
%     \shortstack{
%         $Arrow$\\
%         \begin{tikzpicture}
%           \node [inner] (n3)  {$\tehole^{3}$};
%           \node [innercirc,right=of n3] (i) {$\tnum$};
%           % \draw[red,thick,->] (n3) -- (i);
%         \end{tikzpicture}
%     }
%   };
%   \draw (n1) -- (n3);
%   \draw[dashed] (n2) -- (i);
%    \draw[thick] (A) -- (B);
% \end{tikzpicture}
% \caption{Expanded constraint graph of $C_{ex} = \{ \tarr{\tehole^1}{\tehole^2} \approx \tarr{\tehole^3}{\tnum} \}$}
% \label{fig:arrowgraph}
% \end{figure}

\todo{RAEF: revisit this}
The graph the constraint solver would create given the constraint set $C_{ex1}$ is shown in Figure \ref{fig:C-ex-graph}.

% \begin{figure}[h!]
% \centering
% \begin{tikzpicture}[remember picture,
%   tag/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=3pt,minimum size=0.85cm},
%   holey/.style={rectangle,draw=green!50,fill=green!20,thick,inner sep=5pt,minimum size=0.85cm},
%   ]
%   \node[holey] (hole1) {$\tehole^1$};
%   \node[holey, right=of hole1] (hole0) {$\tehole^0$};
%   \node[holey, below=of hole1] (Arrow) {
%     \shortstack{
%         $Arrow$\\
%         \begin{tikzpicture}
%           \node [holey] (holeL1)  {$\tehole^{\rightarrow_{L(1)}}$};
%           \node [holey, right=of holeL1] (holeR1) {$\tehole^{\rightarrow_{R(1)}}$};
%           % \draw[red,thick,->] (n3) -- (i);
%         \end{tikzpicture}
%     }
%   };
%  \node[tag, below=of holeL1] (num) {$\tnum$};
%  \node[holey, below=of holeR1] (hole3) {$\tehole^3$};
%  \node[holey, right=of holeR1] (hole2) {$\tehole^2$};
%  \node[tag, below=of hole2] (bool) {$\tbool$};
%   % \node[rectangle,minimum size=0.85cm, below=of B] (num) at (2,3) {$\tnum$};
%   % \node[rectangle,minimum size=0.85cm, below=of B, right=of num] (hole3) at (4,3)  {$\tehole^{3}$};
%   \draw (hole1) -- (hole0);
%   \draw (hole1) -- (Arrow);
%   \draw[dashed] (num) -- (holeL1);
%   \draw (hole3) -- (holeR1);
%   \draw[dashed] (bool) -- (hole2);
%   % \draw (n1) -- (n3);
%   % \draw[dashed] (n2) -- (i);
%   %  \draw[thick] (A) -- (B);
% \end{tikzpicture}
% \caption{Constraint graph of $C_{ex4} = \{ \tarr{\tehole^1}{\tehole^2} \approx \tarr{\tehole^3}{\tnum} \}$}
% \label{fig:C-ex-graph}
% \end{figure}

% \begin{figure}[h!]
% \centering
% \begin{tikzpicture}[remember picture,
%   tag/.style={circle,draw=blue!50,fill=blue!20,thick,inner sep=3pt,minimum size=0.85cm},
%   holey/.style={rectangle,draw=green!50,fill=green!20,thick,inner sep=5pt,minimum size=0.85cm},
%   ]
%   \node[holey] (hole1) {$\tehole^1$};
%   \node[holey, right=of hole1] (hole0) {$\tehole^0$};
%   \node[holey, below=of hole1] (Arrow) {
%     \shortstack{
%         $Arrow$\\
%         \begin{tikzpicture}
%           \node [holey] (holeL1)  {$\tehole^{\rightarrow_{L(1)}}$};
%           \node [holey, right=of holeL1] (holeR1) {$\tehole^{\rightarrow_{R(1)}}$};
%           % \draw[red,thick,->] (n3) -- (i);
%         \end{tikzpicture}
%     }
%   };
%  \node[tag, below=of holeL1] (num) {$\tnum$};
%  \node[holey, below=of holeR1] (hole3) {$\tehole^3$};
%  \node[holey, right=of holeR1] (hole2) {$\tehole^2$};
%  \node[tag, below=of hole2] (bool) {$\tbool$};
%   % \node[rectangle,minimum size=0.85cm, below=of B] (num) at (2,3) {$\tnum$};
%   % \node[rectangle,minimum size=0.85cm, below=of B, right=of num] (hole3) at (4,3)  {$\tehole^{3}$};
%   \draw[draw=red] (hole1) -- (hole0);
%   \draw[draw=red] (hole1) -- (Arrow);
%   \draw[dashed] (num) -- (holeL1);
%   \draw (hole3) -- (holeR1);
%   \draw[dashed] (bool) -- (hole2);
%   % \draw (n1) -- (n3);
%   % \draw[dashed] (n2) -- (i);
%   %  \draw[thick] (A) -- (B);
% \end{tikzpicture}
% \caption{Constraint graph of $C_{ex3}$ with $\tehole^1$'s \textit{PossibleTypeSet} traversal in red}
% \label{fig:C-ex-graph-traversal}
% \end{figure}

\subsubsection{PotentialTypeSets and the Graph Construction Algorithm}
Now that we have a clear approach to generating constraint graphs, how might we represent the types that are adjacent to each node? One approach would be to simply store an adjacency list or matrix. However, we'd like to be able to efficiently store all potential hole fillings that can be derived from a type hole's connected components. Since this set grows at a combinatorial rate, we define a new, condensed structure to house our potential fillings without loss of information: a \emph{PotentialTypeSet}.

A \textit{PotentialTypeSet} is a recursive data structure representing the potential solutions for a type hole, inferred from type constraints. A given \emph{PotentialTypeSet} contains \emph{all} of the potential fillings for its associated type hole. To facilitate this, rather than ever substituting types during unification, which results in a loss of the nodes used to transition, we continuously extend some \emph{PotentialTypeSet}. We provide a formalization of \textit{PotentialTypeSet}, \textit{PotentialType}, and their extension below in Figure \ref{fig:possible_type_sets}.

\begin{figure}[hbp!]
\centering
\vspace{-3px} 
$\arraycolsep=4pt\begin{array}{lll}
PotentialTypeSet~~ s & ::= 
single(t) ~\vert~ 
cons(t, s)
\\
PotentialType~~ t & ::= 
  \tnum ~\vert~
  \tbool ~\vert~
  \tehole^p ~\vert~
  \tarr{s}{s}
  \\
\end{array}$
\label{fig:syntax_possible_type_sets}
\caption{Syntax of PotentialTypeSets and PotentialTypes}
\vspace{5px}
\hrule
\[\begin{array}{rcl}
    single(\tarr{s_1}{s_2}) ~\amalg~ single(\tarr{s_3}{s_4}) & = & single({\tarr{(s1 ~\amalg~ s3)}{(s2 ~\amalg~ s4)}}) \\
    single(t) ~\amalg~ single(t') & = & cons(t, single(t')) \\
    cons(t,s) ~\amalg~ single(t) & = & cons(t, s) \\
    cons(\tarr{s_1}{s_2}, s) ~\amalg~ single(\tarr{s_3}{s_4}) & = & cons(\tarr{(s1 ~\amalg~ s3)}{(s2 ~\amalg~ s4)} , s) \\
    cons(t,s) ~\amalg~ cons(t',s') & = & cons(t,s) ~\amalg~ single(t') ~\amalg~ s' \\
\end{array}\] 
\caption{Merging PotentialTypeSets}
\vspace{5px} 
\hrule
\label{fig:possible_type_sets}
\vspace{-5px}
\end{figure}

With this in hand, we formalize the intuitions discussed in section 4.5.1 in a graph construction algorithm. This algorithm accumulates a mapping from incomplete types, which represent our nodes, to their \emph{PotentialTypeSet}, which represents all nodes adjacent to a given incomplete type. Whenever we attempt to create a traversable or solution edge between nodes, we retrieve the \emph{PotentialTypeSet}s of all involved nodes, compute the result of merging them, and update our graph accordingly. We assume the existence of a \emph{Map.add} function that adds a new element to the supplied map if it does not already exist, and otherwise does not change any values. The corresponding definition provided in Figure \ref{fig:algcode_construct_graph}

\begin{figure}[hbt!]
\begin{lstlisting}[escapeinside={(*}{*)}]
let rec construct_graph (~graph=Map.empty(), constraints) =
    match constraints with
    | [] -> graph
    | hd::tl -> (
        match hd with
        | ((*$\tarr{t1_L}{t1_R}$*), (*$\tarr{t2_L}{t2_R}$*)) ->
            construct_graph(~graph, (((*$t1_L$*), (*$t2_L$*)))::(((*$t1_R$*), (*$t2_R$*)))::tl)
        | ((*$\tehole^{p}$*) as hole, t)
        | (t, (*$\tehole^{p}$*) as hole) ->
            let graph = Map.add(graph, hole, hole) in
            if (contains_hole(t)) then (
                let graph = Map.add(graph, t, t) in
                let graph = create_traversable_edge(~graph, t, hole) in
                construct_graph(~graph, tl)
            ) else (
                let graph = create_solution_edge(graph, hole, t) in
                construct_graph(~graph, tl)
            )
        | _ -> construct_graph(~graph, tl)
    );;

\end{lstlisting}
\vspace{-4px}
\hrule
\caption{Constraint graph creation algorithm of type hole inference}
\label{fig:algcode_construct_graph}
\end{figure}

\subsubsection{Computing PotentialTypeSets Using Constraint Graphs} 
The function construct\_graph builds a mapping from each type hole to a \emph{PotentialTypeSet} containing its adjacency list. This \textit{PotentialTypeSet} is only an adjacency list, a subset of the full solution for the type hole. A depth-first search can be used to determine all nodes in the graph which can be reached from a type hole using this adjacency list. Instead of this, we present a variant of Huet's unification algorithm which, instead of halting upon discovering a conflicting constraint, continues past encountered errors and always computes the set of possible types, a \textit{PotentialTypeSet}, for all type holes in the program \cite{G. Huet}.

In order to change our graph construction algorithm to a constraint solver, all we need to do is update our definitions of \lstinline{create_traversable_edge} and \lstinline{create_solution_edge} to use a union find based logic. We outline this approach in \ref{fig:algcode_construct_graph_helpers}, where we assume the use of a mutable union find library, and the functions Map.update and Map.find, which change or return the value associated with some key in a map respectively.

\begin{figure}[htb!]
\begin{lstlisting}[escapeinside={(*}{*)}]
let create_traversable_edge (graph, t1, t2) =
    let (rep1, rep2) = (UnionFind.find(t1), UnionFind.find(t2)) in
    let (s1, s2) = (Map.find(graph, rep1), Map.find(graph, rep2)) in
    let union_rep = UnionFind.union(rep1, rep2) in
    let s_merged = s1 (*$\amalg_{UF}$*) s2 in
    Map.update(graph, union_rep, s_merged);;
let create_solution_edge (graph, t1, t2) =
    let rep1 = UnionFind.find(t1) in
    let s = Map.find(graph, rep1) in
    let s' = s (*$\amalg_{UF}$*) UnionFind.elem(single(t2)) in
    Map.update(graph, t1, s');;
\end{lstlisting}
\vspace{-2px}
\hrule
\caption{Constraint solving algorithm helper functions, using Union-Find.}
\label{fig:algcode_construct_graph_helpers}
\end{figure}

Using these new definitions, the graph returned by construct\_graph will contain the full \textit{PotentialTypeSet} for each type hole, not just an adjacency-list. However, in order to accommodate this change, minor adjustments must be made to the definitions presented in Figure \ref{fig:possible_type_sets} to yield union findable possible type sets and their extension logic, $\amalg_{UF}$. The definitions are somewhat redundant, and are consequently left to Appendix A for reference.

An additional step is taken to mark type holes with an error if their \emph{PotentialTypeSet} contains a cycle that is not a self loop. In Hindley-Milner type inference this is referred to as the occurs-check. We provide sample code for this check in Figure \ref{fig:occurs_check}.

\begin{figure}[htb!]
\begin{lstlisting}[escapeinside={(*}{*)}]
let handle_occurs_check (graph) =
    let annotate_with_error (key) =
        let s = Map.find(graph, UnionFind.find(key) in
        let pass_occurs = is_acyclic(s)
        (key, s, pass_occurs)
    in
    List.map(Map.keys(graph), annotate_with_error);;
\end{lstlisting}
\vspace{-4px}
 \hrule
\caption{Constraint solving algorithm of type hole inference}
\label{fig:occurs_check}
\end{figure}

Type holes are considered solvable if their \textit{PotentialTypeSet} contains a single type. If a type hole's \textit{PotentialTypeSet} contains multiple, conflicting types, or contains no types, or if the type hole fails the occurs check, then it is considered unsolvable. In both cases, helpful visual feedback can be provided to the user as in figure \ref{fig:editor_conflict}.

\subsection{Future Work}
\subsubsection{Other Binary Types}
Suppose we wanted to extend our definitions of constraint generation and solving to contain binary products as discussed in section 2.2. In order to define new constraint generating bidirectional typing rules for this extended syntax of the marked calculus, we follow the same procedures in section 4.4: 
\begin{enumerate}
    \item If an expression is in a hole, we prevent expectations from analysis from reaching beyond the hole and instead constrain the hole itself as needed.
    \item If matched products are ever required on a hole, they constrain it to its matched product form.
\end{enumerate}
We leave a definition of these rules for perusal in Appendix B of the supplemental material.

In order to extend \emph{PotentialTypeSet}s to support binary products, we must slightly adjust our definitions to be more general across different binary type operators. The resulting rules are very similar to those discussed earlier, and are consequently left for review in Appendix C of the supplemental material.

\subsubsection{Parametric Polymorphism}
In order to extend our definitions of \emph{PotentialTypeSet}s to allow parametric polymorphism, we simply update our definitions of \emph{PotentialTypeSet}s as defined below.

\begin{center}
$\arraycolsep=4pt\begin{array}{lll}
PotentialTypeSet~~ s & ::=
single(t) ~\vert~
cons(t, s)
\\
PotentialType~~ t & ::= 
  \tnum ~\vert~
  \tbool ~\vert~
  \TVar ~\vert~
  \tehole^p ~\vert~
  \tarr{p}{p}
  \\
\end{array}$
\end{center}

Here, we choose to represent type variables as a ground type, thus enforcing that type variables are inconsistent with other ground types and consistent with type holes and each other. 

In a system with parametric polymorphism, one thing we may be tempted to do is generalize \emph{PossibleTypeSet}s containing only type holes to a new type variable. However, there are a few subtle issues to be cautious of when considering this extension. Consider the following simple program:

\begin{center}
    \begin{lstlisting}[escapeinside={(*}{*)}, xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
        let x : (*$?^1$*) = (*$\ehole^2$*) in x
    \end{lstlisting}
\end{center}

We can see that x is never constrained to any complete types. In fact, the only constraint in this program is that $?^1 \approx \tehole^2$. Suppose that we were to suggest the type variable \lstinline{'a} as a type hole filling for $?^1$ and the user accepted this suggestion. We'd end up with the following program:

\begin{center}
    \begin{lstlisting}[escapeinside={(*}{*)}, xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
        let x : 'a = (*$\ehole^2$*) in x
    \end{lstlisting}
\end{center}

However, we've run into a stark issue: the only possible expressions that can replace $\tehole^2$ are expressions that analyze against \lstinline{'a}! This is far from ideal: we can see in the initial program that the user didn't express any clear intention for $\tehole^2$ to be strictly polymorphic.

We generalize this notion and make the following observation: whenever the user creates expression holes, there are any number of potential "unknown" constraints that could spawn from the expression hole after it is filled. Indeed, rather than such expression holes being polymorphic, which would effectively represent a lack of constraints on type apart from other unconstrained polymorphic types, they can be constrained to $\mathtt{ANY}$ type after being filled. This status can be effectively represented in a new type of constraint: the $\mathtt{ANY}$ constraint. If a type hole $?^p$ is constrained to $\mathtt{ANY}$, it cannot be generalized to a type variable. On the other hand, if a type hole is never constrained to $\mathtt{ANY}$, it \emph{can} be generalized to a type hole. In order to concretize this notion and allow it to be represented in our constraint graph, we update rules 1f and 1g in Figure \ref{fig:ana-syn} as follows:
\todo{fix examples to fit with the marked lambda calculus}
\begin{equation}
    \inferrule[]{ }{
        \consexptyp{\Gamma}{\llparenthesiscolor \rrparenthesiscolor^n}{\tehole^n}{\{ \tehole^n \approx \mathtt{ANY} \}}
      }\\
      \inferrule[]{
        \consexptyp{\Gamma}{e}{\tau}{C}
       }{
         \consexptyp{\Gamma}{\llparenthesiscolor e \rrparenthesiscolor^n}{\tehole^n}{C \cup \{ \tehole^n \approx \mathtt{ANY} \}}
       }
\end{equation}
These changes ensure that expression holes synthesize type holes that are constrained to the $\mathtt{ANY}$ type. These type holes and any other type holes constrained to them can never be generalized to type variables.

\subsubsection{User Interaction and Conflict Highlighting}
To further the goal of helping users repair their programs, it would be beneficial to assign blame by highlighting the portions of the program responsible for the unsolved status of a \textit{PotentialTypeSet}. To allow this, constraints could be extended to contain the unique identifier of the expression from which they originated. Highlighting all expressions of the program which resulted in an unsolved \textit{PotentialTypeSet}, rather than attempting to localize the error to one particular expression, would result in less confusion and give the user more clues to discover the true source of a type error.
%These identifiers effectively act as reasons for edges within our constraint graph, enabling us to describe the exact series of reasons that caused the inference algorithm to conclude a type hole's solution status.



