\section{Motivating Examples}
\emph{Bidirectional typing} combines type checking, which determines if a program satisfies a given
type, and type synthesis, which generates a type from the program. This gives a simple algorithmic
system in which type information is recursively propagated through terms and allows for local type
inference.

% TODO talk about idea that bidirectional typing makes error localization easy? i.e. why choose
% bidirectional?

Often, programmers are working with program states that are syntactically well-formed but not
well-typed. However, formal typing semantics usually only give meaning to well-typed programs,
leaving ill-typed ones meaningless. This is insufficient for editor services and language servers,
which give users feedback on where and why a program is ill-typed. Traditionally, this has been
performed in an \emph{ad hoc} manner [citations?].

In this section, we motivate a formal calculus for bidirectional type error localization by
exploring different kinds of type errors that may occur.

% TODO state goals: prefer fine-grained over coarser blaming/marking

\subsection{Unbound Variables}
A simple and common example of an error that may occur in programs is the use of an unbound
variable. In this case, editor services often indicate visually that such usages are invalid.

% TODO image of an editor for this example? not sure what else to say about this

\subsection{Inconsistent Types}
Often, the type an expression \emph{should} be is known. Both operands of an addition expression
$\EPlus{\ETrue}{\ENumMV}$, for example, should have the type $\TNum$. In a bidirectional system,
$\ETrue$ and $\ENumMV$ would be analysed against $\TNum$, in which the former check would fail:
$\ETrue$ synthesizes $\TBool$, which is inconsistent with $\TNum$.

% An editor may indicate such an error in different ways. Two obvious ones are considered below: (1)
% indicating an error on $\ETrue$, or (2) indicating an error on the entire expression
% $\EPlus{\ETrue}{\ENumMV}$.
% \[%
  % \EPlus{\ETrue}{\ENumMV} \qquad \EPlus{\ETrue}{\ENumMV}
% \]%
% The former ``blames'' the error on the operand,

% Since the ``fault'' of the error 

% TODO cite real editor/language?

Since expressions typed in analytic mode are checked to satisfy a correct, known type, they are
given ``blame'' when ill-typed.

\subsection{Inconsistent Branches}

\subsection{Correctness}
\begin{theorem}[name=Marking Totality]
  Any syntactically well-formed program may be marked for errors.
\end{theorem}

In the next section, we will formally develop

\section{Marked Lambda Calculus}
\label{sec:calculus}

The previous section surveyed different type error cases. Now, we formally introduce a \emph{marking
calculus} for bidirectional type error localization on the gradually typed lambda calculus above.
This comes as a two-layer system:
%
\begin{itemize}
  \item \textbf{Unmarked expressions} ($\EMName$), which compose the surface-level syntax. Types
    classify unmarked expressions according to a standard bidirectional gradual typing semantics.

  \item \textbf{Marked expressions} ($\ECMName$), which mirror the structure of unmarked expressions
    but are extended with \textbf{error markings}. Every marked expression corresponds to an
    unmarked expression by \emph{mark erasure}.

  \item \textbf{Mark insertion}, which \textbf{marks} any unmarked expression into a marked
    expression, inserting error markings where appropriate.
\end{itemize}
%
That is, we extend the ordinary typing semantics of a language with a secondary ``marked'' language
and define a mapping from ``unmarked'' programs to ``marked'' programs. While the semantics that
follow concern a gradually typed language, a non-gradual system may be recovered straightforwardly
by removing the unknown type and replacing type consistency with equality.

In the interest of space, this overview focuses on the ``interesting'' cases. All rules and
metatheorems may be found in the supplementary appendix, alongside a complete mechanization in the
Agda proof assistant (discussed in \cref{sec:calculus-agda}).

\subsection{Unmarked Expressions}
\label{sec:calculus-uexp}

We consider a gradually typed lambda calculus extended with numbers and conditionals, whose syntax
and bidirectional typing are given in \cref{fig:calculus-syntax-example} and
\cref{fig:calculus-typing-example}, respectively. The base types $\TNum$ and $\TBool$ classify
number and boolean expressions. The number literal corresponding to the mathematical number $n$ is
given by $\ENumMV$, and there is a single addition operation on numeric expressions. $\ETrue$ and
$\EFalse$ correspond to the boolean values $\textsf{true}$ and $\textsf{false}$, and
$\EIf{\EMV_1}{\EMV_2}{\EMV_3}$ gives an if-else structure. In addition to these forms, $\TUnknown$
indicates an unknown type.

\begin{figure}[htbp]
  \[\begin{array}{rrcl}
    \textsf{Type} & \TMV  & \Coloneqq & \TUnknown \mid \TNum \mid \TBool \mid \TArrow{\TMV}{\TMV} \\
    \textsf{Exp}  & \EMV  & \Coloneqq & x \mid \ELam{x}{\TMV}{\EMV} \mid \EAp{\EMV}{\EMV} \\
         &       & \mid         & \ENumMV \mid \EPlus{\EMV}{\EMV}
                   \mid           \ETrue \mid \EFalse \mid \EIf{\EMV}{\EMV}{\EMV}
  \end{array}\]
  \caption{Syntax of the extended gradually typed lambda calculus}
  \label{fig:calculus-syntax-uexp}
\end{figure}

Bidirectional typing employs two mutually defined judgments. \emph{Type synthesis}, written
$\ctxSynType{\ctx}{\EMV}{\TMV}$, establishes that, under the typing context $\ctx$, the expression
$\EMV$ synthesizes or infers the type $\TMV$. \emph{Type analysis}, written
$\ctxAnaType{\ctx}{\EMV}{\TMV}$, states that the expression $\EMV$ may appear where an expression of
type $\TMV$ is expected. The \emph{subsumption} rule (ASubsume) states that if an expression
synthesizes a type, it may be analysed against that type or any \emph{consistent} type.

Note that the subsumption rule requires that $\EMV$ be ``subsumable'', a judgment defined on all
forms except lambda abstractions and if-else expressions. This restricts the usage of subsumption to
a rule of ``last resort'', admitting the unicity of typing.

% \begin{theorem}[name=Unmarked Expression Typing Unicity] \
  % If $\ctxSynType{\ctx}{\EMV}{\TMV}$ and $\ctxSynType{\ctx}{\EMV}{\TMV'}$, then $\TMV = \TMV'$.
% \end{theorem}

\input{figs/calculus-typing-uexp}

The \emph{consistency} judgment $\consistent{\TMV}{\TMV'}$ that appears in the subsumption rule
defines a reflexive and symmetric (but not transitive) relation between types. The unknown type is
additionally consistent with any other type, and arrow types are consistent if their components are.

$\matchedArrow{\TMV}{\TMV_1}{\TMV_2}$ gives that $\TMV$ is a \emph{matched arrow type}, which means
that it may be considered an arrow type. It is purely a technical mechanism to avoid duplication of
rules related to arrow types.

\input{figs/calculus-type-judgments}

\subsection{Marked Expressions}
\label{sec:calculus-mexp}

Marked expressions, $\ECMV$, extend the syntax of unmarked expressions with \emph{explicit error
marks}. As given in the syntax definition of \cref{fig:calculus-syntax-mexp}, there are three such
forms, which mirror the examples discussed previously:
%
\begin{itemize} % TODO not the snappiest names
  \item $\ECUnbound{x}$, the \emph{unbound variable mark}, denotes the usage of an unbound variable.

  \item $\ECInconType{\ECMV}$, the \emph{inconsistent types mark}, occurs when the synthesized type
    of $\ECMV$ is inconsistent with the required type.

  \item $\ECInconBr{\ECMV_1}{\ECMV_2}{\ECMV_3}$, the \emph{inconsistent branches mark}, corresponds
    to an if-else expression where the types of the two branches $\ECMV_2$ and $\ECMV_3$ are
    inconsistent.
\end{itemize}
%
Additional forms may arise as required by the language.

% TODO examples of such?

\begin{figure}[htbp]
  \[\begin{array}{rrcl}
    \ECMName & \ECMV & \Coloneqq & x \mid \ECLam{x}{\TMV}{\ECMV} \mid \ECAp{\ECMV}{\ECMV} \mid \ECLet{x}{\ECMV}{\ECMV} \\
             &       & \mid         & \ECNumMV \mid \ECPlus{\ECMV}{\ECMV}
                       \mid           \ECTrue \mid \ECFalse \mid \ECIf{\ECMV}{\ECMV}{\ECMV} \\
             &       & \mid         & \ECUnbound{x} \mid \ECInconType{\ECMV} \mid \ECInconBr{\ECMV}{\ECMV}{\ECMV}
  \end{array}\]
  \caption{Syntax of marked expressions}
  \label{fig:calculus-syntax-mexp}
\end{figure}

The unmarked version of a marked expression $\ECMV$ may be recovered through \emph{mark erasure},
given by $\erase{\ECMV}$. As in \Cref{fig:calculus-mark-erasure}, this total function may be defined
inductively in a straightforward manner. Observe that erasing the inconsistent branches mark gives
an if-else expression with sub-expression marks recursively erased.

\input{figs/calculus-mark-erasure}

Marked expressions are also typed by a bidirectional system, which, for most forms, closely mirrors
the rules for corresponding unmarked forms. \Cref{fig:calculus-typing-mexp} contains a selection of
the ``interesting'' cases, particularly those concerned with error markings.

\input{figs/calculus-typing-mexp}

% TODO Not really sure how to explain the syntax and typing of marked expressions in an intuitive
% way in relation to unmarked expressions.

For unbound variables $\ECUnbound{x}$, nothing may be said about their types; hence, they synthesize
the unknown type. Inconsistent branch forms behave similarly, as inconsistent types have no join.

There are three rules concerned with the typing of lambda abstractions. MALam1, applies to
$\ECLam{x}{\TMV}{\ECMV}$ if the type $\TMV_3$ analysed against is a matched arrow type
$\TArrow{\TMV_1}{\TMV_2}$ and input type $\TMV_1$ is consistent with the binding ascription $\TMV$.
This corresponds to the lambda rule for unmarked expressions. However, we are additionally concerned
with the cases when $\TMV_3$ is not a matched arrow type or $\TMV_1$ is inconsistent with $\TMV$.
These are described by MALam2 and MALam3.

Alongside the standard subsumption rule, in which an expression that synthesizes a type may be
analysed against any consistent type, MAInconsistentTypes governs most occurrences of the
inconsistent types marking: $\ECInconType{\ECMV}$ analyzes against any type as long as $\ECMV$
synthesizes an inconsistent type. In both cases, we stipulate that subsumption may be applied to
$\ECMV$, written $\subsumable{\ECMV}$. In particular, lambda abstractions and if-else forms are
\emph{not} subsumable, formalizing these rules as ones of ``last resort'', preserving determinism of
typing.

Similarly to lambda abstractions, two rules govern application. In the unmarked syntax, the
application $\EAp{\EMV_1}{\EMV_2}$ was well-typed if the type $\TMV$ synthesized by $\EMV_1$ was a
matched arrow type. This corresponds to the MSAp1 rule for marked expressions. In the case that
$\TMV$ is not a matched arrow type, we require an inconsistent types marking around the

\subsection{Mark Insertion}

\subsection{Correctness}
\label{sec:calculus-correctness}

% Totality

% Well-formedness conditions

\subsection{Alternative Formulations}

\subsection{Non-Gradual System}
\label{sec:calculus-non-gradual}

% TODO extension to non-typing semantics?

\subsection{Mechanization}
\label{sec:calculus-agda}

The metatheory of the calculus has been fully mechanized in the Agda proof assistant [citation]. The
mechanization's documentation contains more details regarding technical decisions made therein.
