\section{Motivating Examples}
\emph{Bidirectional typing} combines type checking, which determines if a program satisfies a given
type, and type synthesis, which generates a type from the program. This gives a simple algorithmic
system in which type information is recursively propagated through terms and allows for local type
inference.

% TODO talk about idea that bidirectional typing makes error localization easy? i.e. why choose
% bidirectional?

Often, programmers are working with program states that are syntactically well-formed but not
well-typed. However, formal typing semantics usually only give meaning to well-typed programs,
leaving ill-typed ones meaningless. This is insufficient for editor services and language servers,
which give users feedback on where and why a program is ill-typed. Traditionally, this has been
performed in an \emph{ad hoc} manner [citations?].

In this section, we motivate a formal calculus for bidirectional type error localization by
exploring different kinds of type errors that may occur.

% TODO state goals: prefer fine-grained over coarser blaming/marking

\subsection{Unbound Variables}
A simple and common example of an error that may occur in programs is the use of an unbound
variable. In this case, editor services often indicate visually that such usages are invalid.

% TODO image of an editor for this example? not sure what else to say about this

\subsection{Inconsistent Types}
Often, the type an expression \emph{should} be is known. Both operands of an addition expression
$\EPlus{\ETrue}{\ENumMV}$, for example, should have the type $\TNum$. In a bidirectional system,
$\ETrue$ and $\ENumMV$ would be analysed against $\TNum$, in which the former check would fail:
$\ETrue$ synthesises $\TBool$, which is inconsistent with $\TNum$.

% An editor may indicate such an error in different ways. Two obvious ones are considered below: (1)
% indicating an error on $\ETrue$, or (2) indicating an error on the entire expression
% $\EPlus{\ETrue}{\ENumMV}$.
% \[%
  % \EPlus{\ETrue}{\ENumMV} \qquad \EPlus{\ETrue}{\ENumMV}
% \]%
% The former ``blames'' the error on the operand,

% Since the ``fault'' of the error 

% TODO cite real editor/language?

Since expressions typed in analytic mode are checked to satisfy a correct, known type, they are
given ``blame'' when ill-typed.

\subsection{Inconsistent Branches}

\subsection{Correctness}
\begin{theorem}[name=Marking Totality]
  Any syntactically well-formed program may be marked for errors.
\end{theorem}

In the next section, we will formally develop

\section{Marked Lambda Calculus}
\label{sec:calculus}

The previous section surveyed different type error cases. Now, we formally introduce a \emph{marking
calculus} for bidirectional type error localization on the gradually typed lambda calculus above.
This comes as a two-layer system:
%
\begin{itemize}
  \item \textbf{Unmarked expressions} (\cref{sec:calculus-uexp}), which compose the surface-level
    syntax. Types classify unmarked expressions according to a standard bidirectional gradual typing
    semantics.

  \item \textbf{Marked expressions} (\cref{sec:calculus-mexp}), which mirror the structure of
    unmarked expressions but are extended with \textbf{error markings}. Every marked expression
    corresponds to an unmarked expression by \emph{mark erasure}.

  \item \textbf{Mark insertion} (\cref{sec:calculus-marking}), which \textbf{marks} any unmarked expression into a marked
    expression, inserting error markings where appropriate.
\end{itemize}
%
That is, we extend the ordinary typing semantics of a language with a secondary ``marked'' language
and define a mapping from ``unmarked'' programs to ``marked'' programs. Note that while the
semantics that follow concern a gradually typed language, a non-gradual system may be recovered
straightforwardly by removing the unknown type and replacing type consistency with equality.

In \cref{sec:calculus-correctness}, we discuss the metatheory that ensures the system---and any such
error localization semantics---to be correct. We follow then by extending the calculus with support
for product types. In the interest of space, this overview focuses on ``interesting'' cases. All
rules and theorems may be found in the supplementary appendix, alongside a complete mechanization
(including the extension with products) in the Agda proof assistant, which is discussed in
\cref{sec:calculus-agda}.

% TODO extension to non-typing semantics?

\subsection{Unmarked Expressions}
\label{sec:calculus-uexp}

We consider a gradually typed lambda calculus extended with numbers and conditionals, whose syntax
and bidirectional typing are given in \cref{fig:calculus-syntax-example} and
\cref{fig:calculus-typing-example}, respectively. The base types $\TNum$ and $\TBool$ classify
number and boolean expressions. The number literal corresponding to the mathematical number $n$ is
given by $\ENumMV$, and there is a single addition operation on numeric expressions. $\ETrue$ and
$\EFalse$ correspond to the boolean values $\textsf{true}$ and $\textsf{false}$, and
$\EIf{\EMV_1}{\EMV_2}{\EMV_3}$ gives an if-else structure. In addition to these forms, $\TUnknown$
indicates an unknown type.

\begin{figure}[htbp]
  \[\begin{array}{rrcl}
    \textsf{Type} & \TMV  & \Coloneqq & \TUnknown \mid \TNum \mid \TBool \mid \TArrow{\TMV}{\TMV} \\
    \textsf{Exp}  & \EMV  & \Coloneqq & x \mid \ELam{x}{\TMV}{\EMV} \mid \EAp{\EMV}{\EMV} \\
         &       & \mid         & \ENumMV \mid \EPlus{\EMV}{\EMV}
                   \mid           \ETrue \mid \EFalse \mid \EIf{\EMV}{\EMV}{\EMV}
  \end{array}\]
  \caption{Syntax of the extended gradually typed lambda calculus}
  \label{fig:calculus-syntax-uexp}
\end{figure}

Bidirectional typing employs two mutually defined judgments. \emph{Type synthesis}, written
$\ctxSynType{\ctx}{\EMV}{\TMV}$, establishes that, under the typing context $\ctx$, the expression
$\EMV$ synthesises or infers the type $\TMV$. \emph{Type analysis}, written
$\ctxAnaType{\ctx}{\EMV}{\TMV}$, states that the expression $\EMV$ may appear where an expression of
type $\TMV$ is expected.

The \emph{subsumption} rule (ASubsume) states that if an expression synthesises a type, it may be
analysed against that type or any \emph{consistent} type. To invoke subsumption, the expression
$\EMV$ must be ``subsumable'', written $\subsumable{\EMV}$, a judgment defined on all forms except
lambda abstractions and if-else expressions. This restricts the usage of subsumption to a rule of
``last resort'', admitting the unicity of typing.

% \begin{theorem}[name=Unmarked Expression Typing Unicity] \
  % If $\ctxSynType{\ctx}{\EMV}{\TMV}$ and $\ctxSynType{\ctx}{\EMV}{\TMV'}$, then $\TMV = \TMV'$.
% \end{theorem}

\input{figs/calculus-typing-uexp}

The \emph{consistency} judgment $\consistent{\TMV}{\TMV'}$ that appears in the subsumption rule
defines a reflexive and symmetric (but not transitive) relation between types. The unknown type is
additionally consistent with any other type, and arrow types are consistent if their components are.
The USAp and UALam rules for application and lambda abstractions are nearly standard, but employ the
judgment $\matchedArrow{\TMV}{\TMV_1}{\TMV_2}$, which gives that $\TMV$ is a \emph{matched arrow
type}, i.e. it may be considered an arrow type. It is purely a technical mechanism to avoid
duplication of rules related to arrow types.

\input{figs/calculus-type-judgments}

The branches of if-else expressions may synthesize different types $\TMV_1$ and $\TMV_2$ as long as
they are consistent. The entire expression then synthesizes the \emph{join}
$\TJoin{\TMV_1}{\TMV_2}$.

\subsection{Marked Expressions}
\label{sec:calculus-mexp}

Marked expressions, $\ECMV$, extend the syntax of unmarked expressions with \emph{explicit error
marks}. As given in the syntax definition of \cref{fig:calculus-syntax-mexp}, there are three such
forms, which mirror the examples discussed previously:
%
\begin{itemize} % TODO not the snappiest names
  \item $\ECUnbound{x}$, the \emph{unbound variable mark}, denotes the usage of an unbound variable.

  \item $\ECInconType{\ECMV}$, the \emph{inconsistent types mark}, occurs when the synthesised type
    of $\ECMV$ is inconsistent with the required type.

  \item $\ECInconBr{\ECMV_1}{\ECMV_2}{\ECMV_3}$, the \emph{inconsistent branches mark}, corresponds
    to an if-else expression where the types of the two branches $\ECMV_2$ and $\ECMV_3$ are
    inconsistent.
\end{itemize}
%
Additional forms may arise as required by the language.

% TODO examples of such?

\begin{figure}[htbp]
  \[\begin{array}{rrcl}
    \ECMName & \ECMV & \Coloneqq & x \mid \ECLam{x}{\TMV}{\ECMV} \mid \ECAp{\ECMV}{\ECMV} \mid \ECLet{x}{\ECMV}{\ECMV} \\
             &       & \mid         & \ECNumMV \mid \ECPlus{\ECMV}{\ECMV}
                       \mid           \ECTrue \mid \ECFalse \mid \ECIf{\ECMV}{\ECMV}{\ECMV} \\
             &       & \mid         & \ECUnbound{x} \mid \ECInconType{\ECMV} \mid \ECInconBr{\ECMV}{\ECMV}{\ECMV}
  \end{array}\]
  \caption{Syntax of marked expressions}
  \label{fig:calculus-syntax-mexp}
\end{figure}

The unmarked version of a marked expression $\ECMV$ may be recovered through \emph{mark erasure},
given by $\erase{\ECMV}$. As in \Cref{fig:calculus-mark-erasure}, this total function may be defined
inductively in a straightforward manner. Observe that erasing the inconsistent branches mark gives
an if-else expression with sub-expression marks recursively erased.

\input{figs/calculus-mark-erasure}

Marked expressions are also typed by a bidirectional system, which, for most forms, closely mirrors
the rules for corresponding unmarked forms. Additional rules handle the cases when certain premises
are not met, requiring then that expressions be wrapped in appropriate error marks.
\Cref{fig:calculus-typing-mexp} contains a selection of these ``interesting'' cases.

In parallel with the rule governing bound variables, MSUnbound types unbound variables. Such
variables must be marked unbound, and since nothing may be said about their types, they synthesise
the unknown type. MSInconsistentBranches corresponds to the USIf, handling the case that the
branches synthesise inconsistent types and hence have no join. Such forms are required to be marked
as such.

\input{figs/calculus-typing-mexp}

% TODO Not really sure how to explain the syntax and typing of marked expressions in an intuitive
% way in relation to unmarked expressions.

In addition to a synthesis rule for lambda abstractions that mirrors USLam, observe that there are
three, instead of one, analytic lambda rules. MALam1 applies to $\ECLam{x}{\TMV}{\ECMV}$ if the type
$\TMV_3$ analysed against is a matched arrow type $\TArrow{\TMV_1}{\TMV_2}$ and the input type
$\TMV_1$ is consistent with the binding ascription $\TMV$. This corresponds to UALam.

However, we are additionally concerned with the cases when $\TMV_3$ is not a matched arrow type or
$\TMV_1$ is inconsistent with $\TMV$. These are described by MALam2 and MALam3. The absence of a
matched arrow type means that $\TMV_3$ must be inconsistent the type synthesised by the lambda, so
the former appropriately requires that the lambda be inside an inconsistent types mark. In this
case, as no output type is known, the body is analysed against the unknown type. Similarly,
inconsistency between the matched input type and binding ascription also implies that $\TMV_3$ is
inconsistent with the synthesised type; MALam3 also requires that the lambda be marked inconsistent,
and the body is analysed against $\TMV_2$.

% TODO mention that every expression synthesises?

Two synthesis rules govern application. In the unmarked language, the application
$\EAp{\EMV_1}{\EMV_2}$ is well-typed if the type $\TMV$ synthesised by $\EMV_1$ is a matched arrow
type $\TArrow{\TMV_1}{\TMV_2}$ and the argument $\EMV_2$ analyses against $\TMV_1$. This corresponds
to the MSAp1 rule for marked expressions. In the case that $\TMV$ is not a matched arrow type, i.e.
it may not be applied, we require $\ECMV_1$ to be inside an inconsistent types mark. In this way, the
blame is placed upon $\ECMV_1$, and this approach is in accordance with the meaning of the
inconsistent types mark.

It is worth noting, however, that $\ECMV_1$ is not actually in analytic position but in synthetic
position. Treating such ``constrained synthetic'' mode specially, we may instead designate a
specialized mark, written $\ECInconMatchedArrow{\ECMV_1}$, for such applications. This yields the
following rule:
\[%
  \judgment{
    \ctxSynType{\ctx}{\ECMV_1}{\TMV} \\
    \notMatchedArrow{\TMV} \\
    \ctxAnaType{\ctx}{\ECMV_2}{\TUnknown}
  }{
    \ctxSynType{\ctx}{\ECApNonMatchedAltAlt{\ECMV_1}{\ECMV_2}}{\TUnknown}
  }{MSAp2'}
\]%
It then becomes natural to extend this to other elimination forms that require the handling of
unmatched types, such as products. We demonstrate such an extension in \cref{sec:calculus-products}.

Finally, alongside the standard subsumption rule, MAInconsistentTypes governs most occurrences of
the inconsistent types mark $\ECInconType{\ECMV}$ analyses against any type as long as $\ECMV$
synthesises an inconsistent type. In both cases, we again stipulate that subsumption may be applied
to $\ECMV$, written $\subsumable{\ECMV}$, for similar reasons as before.

\subsection{Mark Insertion}
\label{sec:calculus-marking}

The central component of the calculus is \emph{mark insertion}, a bidirectional system given by the
following mutually defined judgments. The synthetic insertion judgment
$\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV}$ establishes that under the context $\Gamma$, the
unmarked expression $\EMV$ is ``marked into'' the marked expression $\ECMV$, which synthesizes type
$\TMV$. Analogously, the analytic insertion judgment $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\TMV}$
states that the unmarked expression $\EMV$ is marked into $\ECMV$, which analyses against type
$\TMV$.

% TODO need to better explain why it is bidirectional

\input{figs/calculus-mark-insertion}

The rules for mark insertion are given in \Cref{fig:calculus-mark-insertion}. Observe that they
mirror the typing rules for marked expressions closely: all possible outcomes for fallible premises
are handled and markings are inserted as needed. For example, ISVar and ISUnbound together handle
variable usages. The former yields the same variable in the marked language when it is bound. The
latter marks the variable as unbound if it is not found in the context.

We again find two rules governing the marking of function application. ISAp1 corresponds to MSAp1 as
the ``success case'', recursively marking $\EMV_1$ and $\EMV_2$. Accordingly, ISAp2 parallels MSAp2
as the ``error case''. Similarly, ISIf and ISInconsistentBranches correspond to MSIf and
MSInconsistentBranches, and IALam1, IALam2, and IALam3 correspond to MSLam1, MSLam2, and MSLam3.

\subsection{Correctness}
\label{sec:calculus-correctness}

% Totality

% Well-formedness conditions

% Well-typed expressions have no resulting marks

\subsection{Adding Products}
\label{sec:calculus-products}

\subsection{Mechanization}
\label{sec:calculus-agda}

The metatheory of the calculus has been fully mechanized in the Agda proof assistant [citation]. The
mechanization's documentation contains more details regarding technical decisions made therein.
