\section{The Marked Lambda Calculus}
\label{sec:calculus}

Programmers often work with program states that are syntactically well-formed but not well-typed.
\Cref{fig:calculus-examples} shows common type errors as they appear in the Hazel programming
environment. 
%For example, a simple error that may occur is the use of an unbound variable (\cref{fig:calculus-examples-unbound}).
% As in
% \cref{fig:calculus-examples-unbound}, the editor indicates that the usage of an unbound $y$ is
% invalid by highlighting it in red.

\input{figs/calculus-examples}

% With local type inference, an expression might have a expected type. Consider
% \cref{fig:calculus-examples-inconsistent-types}, in which it is expected that both operands of the
% $+$ operator are numbers. Since $\textsf{true}$ is not a number, a type error arises, and Hazel
% indicates an inconsistency between the expected and actual types of the operand. The application in
% \cref{fig:calculus-examples-app-non-lambda} of a non-lambda leads to a similar kind of error. In
% this case, however, the expectation is not a singular type, but any member of a family of function
% types. \Cref{fig:calculus-examples-inconsistent-branches} presents an error caused by inconsistent
% branch types. As discussed in the introduction, Hazel opts to highlight the entire expression in such a situation,
% while other tools may choose one branch to be ``correct'' and ``blame'' the type mismatch error on
% the other.

The key contribution of this section is the \emph{marked lambda calculus}, a calculus based on the gradually typed lambda calculus (GTLC) that formalizes the mechanism by which errors like these can be localized, and how to  recover, in all cases, from such errors. 
% In brief, the marked lambda calculus formalizes 
% bidirectional type error localization with gradual recovery. 
\Cref{sec:calculus-calculus} introduces the syntax, judgemental structure, guiding metatheory, and then goes through the rules, organized by syntactic form rather than judgement, to build intuition about how the various judgements relate to one another \cite{Siek06a}. All rules and theorems may be found organized by judgement form in the supplementary appendix for reference, 
alongside a complete mechanization in the Agda proof assistant \cite{norell:thesis} (discussed in
\cref{sec:calculus-agda}). We intentionally keep the marked lambda calculus minimal, because it is intended to capture the essential idea and introduce a general pattern that language designers can employ to created mark variants of their own type systems. As an initial example, we consider product types (in \cref{sec:calculus-products}). We then consider a surprisingly subtle combination of features as a more substantial case study: the combination of
destructing let expressions with granular type annotations, in \cref{sec:calculus-let}. Finally, \cref{sec:calculus-poly} briefly explores how
the system might be extended to more complex judgemental structure, e.g. polymorphism.

\subsection{The Core Calculus}
\label{sec:calculus-calculus}

The marked lambda calculus is based on the gradually typed lambda calculus \cite{Siek06a} extended
with numbers, booleans, and empty expression holes \cite{HazelnutSNAPL}. The syntax is given in
\cref{fig:calculus-syntax}. There are two expression languages:
\begin{itemize}
  \item The \textbf{unmarked language}, which is our original language. Expressions of this language
    are called \emph{unmarked expressions}, denoted by the metavariable $\EMV$.

  \item The \textbf{marked language}, which mirrors the structure of the unmarked language but is
    extended with explicit \emph{error marks}. We call expressions of this language
    \emph{marked expressions}, denoted $\ECMV$.
\end{itemize}
In this simple setting, we only need one sort for types, $\tau$. 
The base types $\TNum$ and $\TBool$ classify number and boolean
expressions. The number literal corresponding to the mathematical number $n$ is given by $\ENumMV$,
and there is a single arithmetic operation, addition. $\ETrue$ and
$\EFalse$ are the boolean values and
$\EIf{\EMV_1}{\EMV_2}{\EMV_3}$ is the boolean conditional. Arrow types classify lambdas in the usual way.

$\TUnknown$ is a type hole, which we identify with the unknown type from gradual type theory \cite{Siek06a}.
Finally, to model the edit state of a program in development, $\EEHole$ denotes an \emph{empty expression hole},
used to represent syntactically incomplete portions of the program Ã  la Hazelnut
\cite{HazelnutPOPL}. Note, however, that empty expression holes are not semantically critical to the calculus---they are included to emphasize that the system can handle program sketches.

\begin{figure}[htbp]
  \[\begin{array}{rrcl}
    \TMName  & \TMV  & \Coloneqq & \TUnknown \mid \TNum \mid \TBool \mid \TArrow{\TMV}{\TMV} \mid \TProd{\TMV}{\TMV} \\
    \EMName  & \EMV  & \Coloneqq & x \mid \ELam{x}{\TMV}{\EMV} \mid \EAp{\EMV}{\EMV} \mid \ELet{x}{\EMV}{\EMV}
                       \mid           \ENumMV \mid \EPlus{\EMV}{\EMV} \\
             &       & \mid         & \ETrue \mid \EFalse \mid \EIf{\EMV}{\EMV}{\EMV}
                       \mid           \EPair{\EMV}{\EMV}
                       \mid           \EEHole \\
    \ECMName & \ECMV & \Coloneqq & x \mid \ECLam{x}{\TMV}{\ECMV} \mid \ECAp{\ECMV}{\ECMV} \mid \ECLet{x}{\ECMV}{\ECMV}
                       \mid           \ECNumMV \mid \ECPlus{\ECMV}{\ECMV} \\
             &       & \mid         & \ECTrue \mid \ECFalse \mid \ECIf{\ECMV}{\ECMV}{\ECMV}
                       \mid           \ECEHole \\
             &       & \mid         & \ECUnbound{x} \mid \ECInconType{\ECMV} \mid \ECInconBr{\ECMV}{\ECMV}{\ECMV} \mid \ECInconAsc{\ECMV} \\
             &       & \mid         & \ECSynNonMatchedArrow{\ECMV} \mid \ECAnaNonMatchedArrow{\ECMV}
  \end{array}\]
  \caption{Syntax of the marked lambda calculus.}
  \label{fig:calculus-syntax}
\end{figure}

Before giving any of the rules, let us summarize the overall judgemental structure of the calculus. Note that colors in the judgement forms below are entirely redundant reading aids---color has no semantic significance.

As our starting point, types classify unmarked expressions by a completely standard \emph{bidirectional type system} \cite{BidirTyping,LocalInf}, which employs
two mutually defined judgments. \emph{Type synthesis}, written $\ctxSynTypeU{\ctx}{\EMV}{\TMV}$,
establishes that, under the typing context $\ctx$, the expression $e$ synthesizes or locally infers the type $\TMV$. \emph{Type analysis}, written $\ctxAnaTypeU{\ctx}{\EMV}{\TMV}$,
states that the expression $\EMV$ may appear where an expression of type $\TMV$ is expected.


The key operation is marking, which transforms an unmarked expression into a marked expression,
    inserting error marks where appropriate.
%
This corresponds to a type checking
process with error localization and recovery. The marked language may then serve as a foundation for
other semantic services, such as constraint-based inference (as discussed in
\cref{sec:thi}). 
Intuitively, each of the mark forms corresponds to a different kind of error message that might be shown by an editor or emitted by a compiler. (We do not specify what the error message should say in this paper.)

Throughout the remainder of this section, as we formulate marking for the GTLC, we will motivate and
give precise semantics for each error mark. When the core is extended, new marks may be needed, as we discuss below.

The marked language possesses its own type system, also formulated bidirectionally. We write
$\ctxSynTypeM{\ctx}{\ECMV}{\TMV}$ for synthesis and $\ctxAnaTypeM{\ctx}{\ECMV}{\TMV}$ for analysis (in addition to the color difference, note the subscript on the turnstile to distinguish marked from unmarked typing). 

Finally, the key judgement, \emph{marking}, is also specified bidirectionally. The synthetic marking judgment
$\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV}$ establishes that, under the context $\Gamma$, the
unmarked expression $\EMV$ is ``marked into'' the marked expression $\ECMV$, which synthesizes type
$\TMV$. Analogously, the analytic marking judgment $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\TMV}$
states that $\EMV$ is marked into $\ECMV$, which analyzes against $\TMV$.

How can we ensure that the marking procedure is correctly defined? There are two critical
metatheorems that guide us as we continue. The first is a \emph{totality} of marking:
%
\begin{theorem}[name=Marking Totality] \
  \label{thm:calculus-marking-totality}
  \begin{enumerate}
    \item For all $\ctx$ and $\EMV$, there exist $\ECMV$ and $\TMV$ such that
      $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV}$ and  $\ctxSynTypeM{\ctx}{\ECMV}{\TMV}$.
    \item For all $\ctx$, $\EMV$, and $\TMV$, there exists $\ECMV$ such that
      $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\TMV}$ and $\ctxAnaTypeM{\ctx}{\ECMV}{\TMV}$.
  \end{enumerate}
\end{theorem}
%
That is, we may mark \emph{any} syntactically well-formed program in any context, resulting in a \emph{well-typed} marked program.


Furthermore, since error marks are effectively annotations on top of the program, marking should
preserve syntactic structure modulo those marks. \cref{fig:calculus-mark-erasure} defines \emph{mark erasure}, which converts marked expressions back into unmarked expression by
removing error marks. 
\input{figs/calculus-mark-erasure}

Then, \cref{thm:calculus-marking-well-formedness} provides a
\emph{well-formedness} criterion for marking.
%
\begin{theorem}[name=Marking Well-Formedness] \
  \label{thm:calculus-marking-well-formedness}
  \begin{enumerate}
    \item If $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV}$, then 
      $\erasesTo{\ECMV}{\EMV}$.
    \item If $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\TMV}$, then  and
      $\erasesTo{\ECMV}{\EMV}$.
  \end{enumerate}
\end{theorem}
%

These metatheorems imply that to go from a standard bidirectional system for the unmarked language to a marking system, we need to handle all possible failure modes with appropriate marks and marking logic (otherwise totality would be violated) and without otherwise changing the program (otherwise well-formedness would be violated).
Let us consider each form in turn. 

\subsubsection{Numbers}
\label{sec:calculus-numbers}

To start, let us consider the simple case of numbers. Because of \emph{subsumption}, which is
discussed in more detail next, we need only define a synthesis rule for unmarked numbers, in which
number literals synthesize the type $\TNum$:
%
\begin{mathpar}
  \judgment{ }{
    \ctxSynTypeU{\ctx}{\ENumMV}{\TNum}
  }{USNum}
\end{mathpar}

How should numbers be marked? Quite straightforwardly, we simply give the same number as a marked
expression, synthesizing again $\TNum$. No type errors may occur in a single number, so we only need
the following rules for marking numbers and typing the results: 
%
\begin{mathpar}
  \judgment{
  }{
    \ctxSynFixedInto{\ctx}{\ENumMV}{\ECNumMV}{\TNum}
  }{MKSNum}

  \judgment{ }{
    \ctxSynTypeM{\ctx}{\ECNumMV}{\TNum}
  }{MSNum}
\end{mathpar}

For addition expressions, the type of both operands should be $\TNum$. To denote this in a
bidirectional system, they are analyzed against $\TNum$, giving the following typing rule for
unmarked addition expressions:
%
\begin{mathpar}
  \judgment{
    \ctxAnaTypeU{\ctx}{\EMV_1}{\TNum} \\
    \ctxAnaTypeU{\ctx}{\EMV_2}{\TNum}
  }{
    \ctxSynTypeU{\ctx}{\EPlus{\EMV_1}{\EMV_2}}{\TNum}
  }{USPlus}
\end{mathpar}

The marking rule parallels \textsc{USPlus} closely. Since an expected type for each operand is known,
we shift the responsibility for any type errors to them. Hence, we recursively mark each operand in
analytic mode and rebuild the marked addition expression. The typing rule for marked addition
expressions then mirrors \textsc{USPlus} exactly.
%
\begin{mathpar}
  \judgment{
    \ctxAnaFixedInto{\ctx}{\EMV_1}{\ECMV_1}{\TNum} \\
    \ctxAnaFixedInto{\ctx}{\EMV_2}{\ECMV_2}{\TNum}
  }{
    \ctxSynFixedInto{\ctx}{\EPlus{\EMV_1}{\EMV_2}}{\ECPlus{\ECMV_1}{\ECMV_2}}{\TNum}
  }{MKSPlus}

  \judgment{
    \ctxAnaTypeM{\ctx}{\ECMV_1}{\TNum} \\
    \ctxAnaTypeM{\ctx}{\ECMV_2}{\TNum}
  }{
    \ctxSynTypeM{\ctx}{\ECPlus{\ECMV_1}{\ECMV_2}}{\TNum}
  }{MSPlus}
\end{mathpar}

\subsubsection{Subsumption}
\label{sec:calculus-subsumption}

Only synthetic rules were necessary for typing numbers and addition because of \emph{subsumption},
given below, which states that if an expression synthesizes a type, it may also be analyzed against
that type or any \emph{consistent} type.
\[%
  \judgment{
    \ctxSynTypeU{\ctx}{\EMV}{\TMV'} \\
    \consistent{\TMV}{\TMV'} \\
    \subsumable{\EMV}
  }{
    \ctxAnaTypeU{\ctx}{\EMV}{\TMV}
  }{UASubsume}
\]%
We rely on the notion of \emph{type consistency} from gradual type theory, which defines a reflexive
and symmetric (but not transitive) relation between types, writing $\consistent{\TMV_1}{\TMV_2}$ to
mean that $\TMV_1$ is consistent with $\TMV_2$. Defined in \cref{fig:calculus-consistency}, this
replaces the notion of \emph{type equality} to relate the unknown type to all other types.

\begin{figure}[htbp]
  \raggedright
  \judgbox{\ensuremath{\consistent{\TMV_1}{\TMV_2}}} $\TMV_1$ is consistent with $\TMV_2$
  %
  \begin{mathpar}
    \judgment{ }{
      \consistent{\TUnknown}{\TMV}
    }{TCUnknown1}

    \judgment{ }{
      \consistent{\TMV}{\TUnknown}
    }{TCUnknown2}

    \judgment{ }{
      \consistent{\TMV}{\TMV}
    }{TCRefl}

    \judgment{
      \consistent{\TMV_1}{\TMV_1'} \\
      \consistent{\TMV_2}{\TMV_2'} \\
    }{
      \consistent{\TArrow{\TMV_1}{\TMV_2}}{\TArrow{\TMV_1'}{\TMV_2'}}
    }{TCArr}
  \end{mathpar}
  \vspace{-10px}
  \caption{Type consistency.}
  \label{fig:calculus-consistency}
\end{figure}

Hence, when checking $\ENumMV$ against a known expected type, subsumption checks that the type is
consistent with $\TNum$, the type that $\ENumMV$ synthesizes. This succeeds for $\TUnknown$ and
$\TNum$.

We also restrict the usage of subsumption to ``subsumable'' syntactic forms, written
$\subsumable{\EMV}$. This judgment is defined on all syntactic forms except lambda abstractions and
conditionals, the only ones with both synthesis and analysis rules (see below). In other words, we restrict subsumption to
be the rule of ``last resort'', which is necessary to establish that marking and typing are
deterministic (discussed later in \cref{thm:calculus-marking-unicity}).

Now, to define analytic marking on forms without explicit analytic typing rules, we also need
subsumption rules for marking and marked expression typing. Note that we define a analogous notion
of ``subsumability'' for marked expressions, written $\subsumable{\ECMV}$.
%
\begin{mathpar}
  \judgment{
    \ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV'} \\
    \consistent{\TMV}{\TMV'} \\
    \subsumable{\EMV}
  }{
    \ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\TMV}
  }{MKASubsume}

  \judgment{
    \ctxSynTypeM{\ctx}{\ECMV}{\TMV'} \\
    \consistent{\TMV}{\TMV'} \\
    \subsumable{\ECMV}
  }{
    \ctxAnaTypeM{\ctx}{\ECMV}{\TMV}
  }{MASubsume}
\end{mathpar}

But what happens when the synthesized type of an expression is \emph{not} consistent with the
expected type, i.e. that the premise $\consistent{\TMV}{\TMV'}$ fails? Recalling the example of
\cref{fig:calculus-examples-inconsistent-types}, subsumption would be used to analyze $\ETrue$
against $\TNum$ in $\EPlus{\ETrue}{1}$, which fails since $\inconsistent{\TNum}{\TBool}$, i.e.
\textsc{UASubsume} does not apply, and traditional typing semantics would simply fail the type
checking process at this point. \textsc{MKASubsume} would also not be applicable, leaving marking
undefined in those cases.

To satisfy marking totality, such a possibility motivates an \emph{inconsistent type mark}
$\ECInconType{\ECMV}$, which is applied when the synthesized type of $\ECMV$ is inconsistent
with the expected type:
%
\begin{mathpar}
  \judgment{
    \ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV'} \\
    \inconsistent{\TMV}{\TMV'} \\
    \subsumable{\EMV}
  }{
    \ctxAnaFixedInto{\ctx}{\EMV}{\ECInconType{\ECMV}}{\TMV}
  }{MKAInconsistentTypes}

  \judgment{
    \ctxSynTypeM{\ctx}{\ECMV}{\TMV'} \\
    \inconsistent{\TMV}{\TMV'} \\
    \subsumable{\ECMV}
  }{
    \ctxAnaTypeM{\ctx}{\ECInconType{\ECMV}}{\TMV}
  }{MAInconsistentTypes}
\end{mathpar}
%
Observe that the premises of \textsc{MKAInconsistentTypes} are identical to those of
\textsc{MKASubsume}, except that $\inconsistent{\TMV}{\TMV'}$. By marking an error, type-checking
may continue---instead of simply failing.

\subsubsection{Variables}
\label{sec:calculus-variables}

Let us now consider the case of variables. Typing in the unmarked language is standard, and because
of subsumption, only a synthetic rule is required:
\[%
  \judgment{
    \inCtx{\ctx}{x}{\TMV}
  }{
    \ctxSynTypeU{\ctx}{x}{\TMV}
  }{USVar}
\]%
That is, if $x$ is bound to a type in the typing context, it synthesizes that type.
Straightforwardly, marking converts an unmarked variable into the same variable via the following
rules:
%
\begin{mathpar}
  \judgment{
    \inCtx{\ctx}{x}{\TMV}
  }{
    \ctxSynFixedInto{\ctx}{x}{x}{\TMV}
  }{MKSVar}

  \judgment{
    \inCtx{\ctx}{x}{\TMV}
  }{
    \ctxSynTypeM{\ctx}{x}{\TMV}
  }{MSVar}
\end{mathpar}

However, consider the case that a variable, such as $y$ in \cref{fig:calculus-examples-unbound}, is \emph{not}
bound. Again, \textsc{USVar} would not apply. A total marking should, however, report the error and
continue, motivating an \emph{unbound variable mark} $\ECUnbound{x}$ and the accompanying rules:
%
\begin{mathpar}
  \judgment{
    \notInCtx{\ctx}{x}
  }{
    \ctxSynFixedInto{\ctx}{x}{\ECUnbound{x}}{\TUnknown}
  }{MKSUnbound}

  \judgment{
    \notInCtx{\ctx}{x}
  }{
    \ctxSynTypeM{\ctx}{\ECUnbound{x}}{\TUnknown}
  }{MSUnbound}
\end{mathpar}
%
An unbound variable is marked as such, and since nothing may be said about their types, we
synthesize the unknown type. Similarly to the inconsistent type mark, this allows type checking to
proceed, with usage of the unbound variable permitted in any expression. \todo{intution for
correctness} \todo{relate to gradual recovery}

\subsubsection{Lambda Abstractions}
\label{sec:calculus-lambda-abstractions}

Unlike numbers and variables, there are explicit synthesis and analysis rules for unmarked lambda
abstractions. This is because expected input and output types are known, and we may verify that the
type annotation and body match them.
%
\begin{mathpar}
  \judgment{
    \ctxSynTypeU{\extendCtx{\ctx}{x}{\TMV}}{\EMV}{\TMV_2}
  }{
    \ctxSynTypeU{\ctx}{\ELam{x}{\TMV_1}{\EMV}}{\TArrow{\TMV_1}{\TMV_2}}
  }{USLam}

  \judgment{
    \matchedArrow{\TMV_3}{\TMV_1}{\TMV_2} \\
    \consistent{\TMV}{\TMV_1} \\
    \ctxAnaTypeU{\extendCtx{\ctx}{x}{\TMV}}{\EMV}{\TMV_2}
  }{
    \ctxAnaTypeU{\ctx}{\ECLam{x}{\TMV}{\EMV}}{\TMV_3}
  }{UALam}
\end{mathpar}
%
The synthesis rule is standard. Analysis employs the judgment $\matchedArrow{\TMV}{\TMV_1}{\TMV_2}$,
which establishes that $\TMV$ is a \emph{matched arrow type} \cite{cimini:2016}, i.e. it may be
considered an arrow type. Defined in \cref{fig:calculus-matched-arrow}, this notion is purely a
technical mechanism to avoid duplication of rules related to arrow types.

\begin{figure}[htbp]
  \raggedright
  \judgbox{\ensuremath{\matchedArrow{\TMV}{\TMV_1}{\TMV_2}}} $\TMV$ has matched arrow type $\TArrow{\TMV_1}{\TMV_2}$
  %
  \begin{mathpar}
    \judgment{ }{
      \matchedArrow{\TUnknown}{\TUnknown}{\TUnknown}
    }{TMAUnknown}

    \judgment{ }{
      \matchedArrow{\TArrow{\TMV}{\TMV}}{\TMV}{\TMV}
    }{TMAArr}
  \end{mathpar}
  \vspace{-10px}
  \caption{Matched arrow types.}
  \label{fig:calculus-matched-arrow}
\end{figure}

The synthesis rule for marking intuitively follows \textsc{USLam} closely. We should recursively
mark the body with an extended context binding $x$ to $\TMV$ and construct a new marked lambda
abstraction:
%
\begin{mathpar}
  \judgment{
    \ctxSynFixedInto{\extendCtx{\ctx}{x}{\TMV_1}}{\EMV}{\ECMV}{\TMV_2}
  }{
    \ctxSynFixedInto{\ctx}{\ELam{x}{\TMV_1}{\EMV}}{\ELam{x}{\TMV_1}{\ECMV}}{\TArrow{\TMV_1}{\TMV_2}}
  }{MKSLam}

  \judgment{
    \ctxSynTypeM{\extendCtx{\ctx}{x}{\TMV}}{\ECMV}{\TMV_2}
  }{
    \ctxSynTypeM{\ctx}{\ECLam{x}{\TMV_1}{\ECMV}}{\TArrow{\TMV_1}{\TMV_2}}
  }{MSLam}
\end{mathpar}
%
Similarly, we construct corresponding analytic rules:
%
\begin{mathpar}
  \judgment{
    \matchedArrow{\TMV_3}{\TMV_1}{\TMV_2} \\
    \consistent{\TMV}{\TMV_1} \\\\
    \ctxAnaFixedInto{\extendCtx{\ctx}{x}{\TMV}}{\EMV}{\ECMV}{\TMV_2}
  }{
    \ctxAnaFixedInto{\ctx}{\ELam{x}{\TMV}{\EMV}}{\ECLam{x}{\TMV}{\ECMV}}{\TMV_3}
  }{MKALam1}

  \judgment{
    \matchedArrow{\TMV_3}{\TMV_1}{\TMV_2} \\
    \consistent{\TMV}{\TMV_1} \\\\
    \ctxAnaTypeM{\extendCtx{\ctx}{x}{\TMV}}{\ECMV}{\TMV_2}
  }{
    \ctxAnaTypeM{\ctx}{\ECLam{x}{\TMV}{\ECMV}}{\TMV_3}
  }{MALam1}
\end{mathpar}
%
However, recalling totality, we look again to the premises of \textsc{UALam} to see what type errors
may arise. First, what if $\TMV_3$ is not a matched arrow type? This would be the case if it were
$\TNum$, for example. The lambda abstraction's synthesized type would indeed be inconsistent with
the expected type, but this case is slightly distinct from that of the inconsistent types mark: the
lambda expression is in analytic position. Instead, we mark $\ECAnaNonMatchedArrow{\ECMV}$ to
indicate that an expression of the non-matched arrow type $\TMV_3$ was expected, but a lambda
abstraction was encountered.
%
\begin{mathpar}
  \judgment{
    \notMatchedArrow{\TMV_3} \\
    \ctxAnaFixedInto{\extendCtx{\ctx}{x}{\TMV}}{\EMV}{\ECMV}{\TUnknown}
  }{
    \ctxAnaFixedInto{\ctx}{\ELam{x}{\TMV}{\EMV}}{\ECLamAnaNonMatchedArrow{x}{\TMV}{\ECMV}}{\TMV_3}
  }{MKALam2}

  \judgment{
    \notMatchedArrow{\TMV_3} \\
    \ctxAnaTypeM{\extendCtx{\ctx}{x}{\TMV}}{\ECMV}{\TUnknown}
  }{
    \ctxAnaTypeM{\ctx}{\ECLamAnaNonMatchedArrow{x}{\TMV}{\ECMV}}{\TMV_3}
  }{MALam2}
\end{mathpar}
%
Though no expected output type is known, we still need to check and mark the body; it is thus
analyzed against the unknown type in \textsc{MKALam2}.

In this example language, the distinction from the inconsistent type mark is of reduced
significance---all expressions synthesize a type. However, the addition of unannotated lambda
abstractions, for example, would necessitate such a disctinction.

Another error arises when $\matchedArrow{\TMV_3}{\TMV_1}{\TMV_2}$, but
$\inconsistent{\TMV}{\TMV_1}$, i.e. the actual type annotation for $x$ is inconsistent with the
expected input type. The \emph{inconsistent ascription mark} $\ECInconAsc{x}$ indicates exactly this
error, and we add a final pair of analytic rules:
%
\begin{mathpar}
  \judgment{
    \matchedArrow{\TMV_3}{\TMV_1}{\TMV_2} \\
    \inconsistent{\TMV}{\TMV_1} \\\\
    \ctxAnaFixedInto{\extendCtx{\ctx}{x}{\TMV_1}}{\EMV}{\ECMV}{\TMV_2}
  }{
    \ctxAnaFixedInto{\ctx}{\ELam{x}{\TMV}{\EMV}}{\ECLamInconAsc{x}{\TMV}{\ECMV}}{\TMV_3}
  }{MKALam3}

  \judgment{
    \matchedArrow{\TMV_3}{\TMV_1}{\TMV_2} \\
    \inconsistent{\TMV}{\TMV_1} \\\\
    \ctxAnaTypeM{\extendCtx{\ctx}{x}{\TMV_1}}{\ECMV}{\TMV_2}
  }{
    \ctxAnaTypeM{\ctx}{\ECLamInconAsc{x}{\TMV}{\ECMV}}{\TMV_3}
  }{MALam3}
\end{mathpar}

\subsubsection{Applications}
\label{sec:calculus-applications}

In the unmarked language, only a synthesis rule is necessary for applications:
\[%
  \judgment{
    \ctxSynTypeU{\ctx}{\EMV_1}{\TMV} \\
    \matchedArrow{\TMV}{\TMV_1}{\TMV_2} \\
    \ctxAnaTypeU{\ctx}{\EMV_2}{\TMV_1}
  }{
    \ctxSynTypeU{\ctx}{\EAp{\EMV_1}{\EMV_2}}{\TMV_2}
  }{USAp}
\]%
Following the same methodology, we have the following marking and typing
rules:
%
\begin{mathpar}
  \judgment{
    \ctxSynFixedInto{\ctx}{\EMV_1}{\ECMV_1}{\TMV} \\
    \matchedArrow{\TMV}{\TMV_1}{\TMV_2} \\\\
    \ctxAnaFixedInto{\ctx}{\EMV_2}{\ECMV_2}{\TMV_1} \\
  }{
    \ctxSynFixedInto{\ctx}{\EAp{\EMV_1}{\EMV_2}}{\ECAp{\ECMV_1}{\ECMV_2}}{\TMV_2}
  }{MKSAp1}

  \judgment{
    \ctxSynTypeM{\ctx}{\ECMV_1}{\TMV} \\
    \matchedArrow{\TMV}{\TMV_1}{\TMV_2} \\\\
    \ctxAnaTypeM{\ctx}{\ECMV_2}{\TMV_1}
  }{
    \ctxSynTypeM{\ctx}{\ECAp{\ECMV_1}{\ECMV_2}}{\TMV_2}
  }{MSAp1}
\end{mathpar}

Again, to satisfy totality, we must consider the case when $\TMV$ is not a matched arrow type, such
as in the example of \cref{fig:calculus-examples-app-non-lambda}. There is no expected type for the
argument, so we perform analytic marking on $\EMV_2$ against the unknown type. In this case, it is
not quite right to mark $\EMV_1$ with the inconsistent type mark; rather than any single type, it is
any type within the family of arrow types that is expected. For such a ``constrained'' synthetic
mode, we use a specialized mark $\ECSynNonMatchedArrow{\ECMV}$, which indicates that $\ECMV$ was
expected to be a function---but was not. The output type is unknown, so the entire expression
synthesizes the unknown type.
%
\begin{mathpar}
  \judgment{
    \ctxSynFixedInto{\ctx}{\EMV_1}{\ECMV_1}{\TMV} \\
    \notMatchedArrow{\TMV} \\
    \ctxAnaFixedInto{\ctx}{\EMV_2}{\ECMV_2}{\TUnknown}
  }{
    \ctxSynFixedInto{\ctx}{\EAp{\EMV_1}{\EMV_2}}{\ECApSynNonMatchedArrow{\ECMV_1}{\ECMV_2}}{\TUnknown}
  }{MKSAp2}

  \judgment{
    \ctxSynTypeM{\ctx}{\ECMV_1}{\TMV} \\
    \notMatchedArrow{\TMV} \\
    \ctxAnaTypeM{\ctx}{\ECMV_2}{\TUnknown}
  }{
    \ctxSynTypeM{\ctx}{\ECApSynNonMatchedArrow{\ECMV}{\ECMV}}{\TUnknown}
  }{MSAp2}
\end{mathpar}

It is natural to extend this approach to other elimination forms that require the handling of
unmatched types, such as products. Indeed, the same approach is taken for projections in
\cref{sec:calculus-products}. 
% Another approach might indicate the same kind of error but mark the
% entire application.

\subsubsection{Booleans}
\label{sec:calculus-booleans}

The boolean values are similar to numbers: 
%
\begin{mathpar}
  \judgment{ }{
    \ctxSynTypeU{\ctx}{\ETrue}{\TBool}
  }{USTrue}

  \judgment{
  }{
    \ctxSynFixedInto{\ctx}{\ETrue}{\ECTrue}{\TBool}
  }{MKSTrue}

  \judgment{ }{
    \ctxSynTypeM{\ctx}{\ECTrue}{\TBool}
  }{MSTrue} \\

  \judgment{ }{
    \ctxSynTypeU{\ctx}{\EFalse}{\TBool}
  }{USFalse}

  \judgment{
  }{
    \ctxSynFixedInto{\ctx}{\EFalse}{\ECFalse}{\TBool}
  }{MKSFalse}

  \judgment{ }{
    \ctxSynTypeM{\ctx}{\ECFalse}{\TBool}
  }{MSFalse}
\end{mathpar}

Conditionals, however, are an interesting case. In the unmarked language, we have both explicit
synthetic and analytic rules:
%
\begin{mathpar}
  \judgment{
    \ctxAnaTypeU{\ctx}{\EMV_1}{\TBool} \\\\
    \ctxSynTypeU{\ctx}{\EMV_2}{\TMV_1} \\
    \ctxSynTypeU{\ctx}{\EMV_3}{\TMV_2}
  }{
    \ctxSynTypeU{\ctx}{\EIf{\EMV_1}{\EMV_2}{\EMV_3}}{\TJoin{\TMV_1}{\TMV_2}}
  }{USIf}

  \judgment{
    \ctxAnaTypeU{\ctx}{\EMV_1}{\TBool} \\\\
    \ctxAnaTypeU{\ctx}{\EMV_1}{\TMV} \\
    \ctxAnaTypeU{\ctx}{\EMV_2}{\TMV}
  }{
    \ctxAnaTypeU{\ctx}{\ECIf{\EMV_1}{\EMV_2}{\EMV_3}}{\TMV}
  }{UAIf}
\end{mathpar}
%
In synthetic position, conditionals synthesize the \emph{join} of the branch types $\TMV_1$ and
$\TMV_2$, which we define inductively in \cref{fig:calculus-type-join}. We choose the ``more
specific'' type of the two\todo{intuition for why this is correct}. In analytic position, since
there is an expected type for both branches, we shift the blame for any errors to them.

\newcommand{\joinsTo}[3]{\ensuremath{\TJoin{#1}{#2} & = & #3}}
\begin{figure}[htbp]
  \raggedright
  \judgbox{\ensuremath{\TJoin{\TMV_1}{\TMV_2}}} is a \emph{partial} metafunction defined as follows:
  %
  \[\begin{array}{rcl}
    \joinsTo{\TUnknown}{\TMV}{\TMV} \\
    \joinsTo{\TMV}{\TUnknown}{\TMV} \\
    \joinsTo{\TNum}{\TNum}{\TNum} \\
    \joinsTo{\TBool}{\TBool}{\TBool} \\
    \joinsTo{(\TArrow{\TMV_1}{\TMV_2})}{(\TArrow{\TMV_1'}{\TMV_2'})}{\TArrow{(\TJoin{\TMV_1}{\TMV_1'})}{(\TJoin{\TMV_2}{\TMV_2'})}}
  \end{array}\]
  \vspace{-10px}
  \caption{Type join.}
  \label{fig:calculus-type-join}
\end{figure}

Following \textsc{USIf} and \textsc{UAIf}, we may derive the following marking and typing rules.
% Similar to previous cases, we recursively mark the guard and branches, constructing the marked
% conditional from the results.
%
\begin{mathpar}
  \judgment{
    \ctxAnaFixedInto{\ctx}{\EMV_1}{\ECMV_1}{\TBool} \\\\
    \ctxSynFixedInto{\ctx}{\EMV_2}{\ECMV_2}{\TMV_1} \\
    \ctxSynFixedInto{\ctx}{\EMV_3}{\ECMV_3}{\TMV_2}
  }{
    \ctxSynFixedInto{\ctx}{\EIf{\EMV_1}{\EMV_2}{\EMV_3}}{\ECIf{\ECMV_1}{\ECMV_2}{\ECMV_3}}{\TJoin{\TMV_1}{\TMV_2}}
  }{MKSIf}

  \judgment{
    \ctxAnaTypeM{\ctx}{\ECMV_1}{\TBool} \\\\
    \ctxSynTypeM{\ctx}{\ECMV_2}{\TMV_1} \\
    \ctxSynTypeM{\ctx}{\ECMV_3}{\TMV_2}
  }{
    \ctxSynTypeM{\ctx}{\ECIf{\ECMV_1}{\ECMV_2}{\ECMV_3}}{\TJoin{\TMV_1}{\TMV_2}}
  }{MSIf} \\

  \judgment{
    \ctxAnaFixedInto{\ctx}{\EMV_1}{\ECMV_1}{\TBool} \\\\
    \ctxAnaFixedInto{\ctx}{\EMV_2}{\ECMV_2}{\TMV} \\
    \ctxAnaFixedInto{\ctx}{\EMV_3}{\ECMV_3}{\TMV} \\
  }{
    \ctxAnaFixedInto{\ctx}{\EIf{\EMV_1}{\EMV_2}{\EMV_3}}{\ECIf{\ECMV_1}{\ECMV_2}{\ECMV_3}}{\TMV}
  }{MKAIf}

  \judgment{
    \ctxAnaTypeM{\ctx}{\ECMV_1}{\TBool} \\\\
    \ctxAnaTypeM{\ctx}{\ECMV_1}{\TMV} \\
    \ctxAnaTypeM{\ctx}{\ECMV_2}{\TMV}
  }{
    \ctxAnaTypeM{\ctx}{\ECIf{\ECMV_1}{\ECMV_2}{\ECMV_3}}{\TMV}
  }{MAIf}
\end{mathpar}

However, in synthetic position, it may be the case that the two branch types have no join. This
occurs, in fact, when they are inconsistent, motivating the \emph{the inconsistent branches mark}
$\ECInconBr{\ECMV}{\ECMV}{\ECMV}$. Then, adding the following rules ensures totality on
conditionals:
%
\begin{mathpar}
  \judgment{
    \ctxAnaFixedInto{\ctx}{\EMV_1}{\ECMV_1}{\TBool} \\
    \ctxSynFixedInto{\ctx}{\EMV_2}{\ECMV_2}{\TMV_1} \\\\
    \ctxSynFixedInto{\ctx}{\EMV_3}{\ECMV_3}{\TMV_2} \\
    \inconsistent{\TMV_1}{\TMV_2}
  }{
    \ctxSynFixedInto{\ctx}{\EIf{\EMV_1}{\EMV_2}{\EMV_3}}{\ECInconBr{\ECMV_1}{\ECMV_2}{\ECMV_3}}{\TUnknown}
  }{MKSInconsistentBranches}

  \judgment{
    \ctxAnaTypeM{\ctx}{\ECMV_1}{\TBool} \\
    \ctxSynTypeM{\ctx}{\ECMV_2}{\TMV_1} \\\\
    \ctxSynTypeM{\ctx}{\ECMV_3}{\TMV_2} \\
    \inconsistent{\TMV_1}{\TMV_2}
  }{
    \ctxSynTypeM{\ctx}{\ECInconBr{\ECMV_1}{\ECMV_2}{\ECMV_3}}{\TUnknown}
  }{MSInconsistentBranches}
\end{mathpar}

The framework also allows for other localization approaches. For example, as discussed at the
beginning of the section, we may regard the first branch as ``correct'' and localize any errors to
the second. The following rule formalizes such a design:
\[%
  \judgment{
    \ctxAnaFixedInto{\ctx}{\EMV_1}{\ECMV_1}{\TBool} \\
    \ctxSynFixedInto{\ctx}{\EMV_2}{\ECMV_2}{\TMV} \\
    \ctxAnaFixedInto{\ctx}{\EMV_3}{\ECMV_3}{\TMV}
  }{
    \ctxSynFixedInto{\ctx}{\EIf{\EMV_1}{\EMV_2}{\EMV_3}}{\ECIf{\ECMV_1}{\ECMV_2}{\ECMV_3}}{\TMV}
  }{MKSIf'}
\]%
% Of course, corresponding unmarked and marked typing rules would follow similar structure, and other
% heuristics may be devised for different kinds of branching structures.

\subsubsection{Holes}
For completeness, we finish the development of the marked lambda calculus on the extended GTLC with
the marking of empty holes, which are never marked.
%
\begin{mathpar}
  \judgment{ }{
    \ctxSynTypeU{\ctx}{\EEHole}{\TUnknown}
  }{USHole}

  \judgment{ }{
    \ctxSynFixedInto{\ctx}{\EEHole}{\ECEHole}{\TUnknown}
  }{MKSHole}
  
  \judgment{ }{
    \ctxSynTypeM{\ctx}{\ECEHole}{\TUnknown}
  }{MSHole}
\end{mathpar}

\subsubsection{Additional Metatheorems}
To conclude this section, we present two more metatheorems that help ensure correctness of the
system. Though \cref{thm:calculus-marking-well-formedness} guarantees that marking does not change
the syntactic structure of a program, it makes no statement about the presence of error marks in the
resulting marked program. 
\cref{thm:calculus-marking-well-ill-typed} established that well-typed expressions are left unmarked and ill-typed expressions have at least one mark.

\begin{theorem}[name=Marking of Well-Typed/Ill-Typed Expressions] \
  \label{thm:calculus-marking-well-ill-typed}
  \begin{enumerate}
    \item \begin{enumerate}
        \item If $\ctxSynTypeU{\ctx}{\EMV}{\TMV}$ and $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV}$,
          then $\markless{\ECMV}$.
        \item If $\ctxAnaTypeU{\ctx}{\EMV}{\TMV}$ and $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\TMV}$,
          then $\markless{\ECMV}$.
      \end{enumerate}

    \item \begin{enumerate}
        \item If there does not exist $\TMV$ such that $\ctxSynTypeU{\ctx}{\EMV}{\TMV}$, then for
          all $\ECMV$ and $\TMV'$ such that $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV'}$, it is not
          the case that $\markless{\ECMV}$.
        \item If there does not exist $\TMV$ such that $\ctxAnaTypeU{\ctx}{\EMV}{\TMV}$, then for
          all $\ECMV$ and $\TMV'$ such that $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV}{\TMV'}$, it is not
          the case that $\markless{\ECMV}$.
      \end{enumerate}
  \end{enumerate}
\end{theorem}
%
Finally, no less importantly, marking is deterministic. This is given by
\cref{thm:calculus-marking-unicity}.
%
\begin{theorem}[name=Marking Unicity] \
  \label{thm:calculus-marking-unicity}
  \begin{enumerate}
    \item If $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV_1}{\TMV_1}$ and
      $\ctxSynFixedInto{\ctx}{\EMV}{\ECMV_2}{\TMV_2}$, then $\ECMV_1 = \ECMV_2$ and $\TMV_1 =
      \TMV_2$.
    \item If $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV_1}{\TMV}$ and
      $\ctxAnaFixedInto{\ctx}{\EMV}{\ECMV_2}{\TMV}$, then $\ECMV_1 = \ECMV_2$.
  \end{enumerate}
\end{theorem}
%
Together, totality and unicity give that marking may be implemented as a total
function. Indeed, given the algorithmic nature of bidirectional typing, it is fairly direct to implement these rules.

\subsection{Adding Binary Products}
\label{sec:calculus-products}

The marked lambda calculus is intended as a minimal core. The methodology described above can be used to extend the marked lambda calculus with new typing features. For example, let us add binary product types, written $\TProd{\TMV_1}{\TMV_2}$. In the interest of space, we focus on
aspects related to marking and omit standard rules; a comprehensive set of rules is found in the supplemental material.

% First, we extend the syntax of types and the accompanying notions of consistency and join, which
% closely mirror the definitions for arrow types. Additionally, analogous to the notion of matched
% arrow types, we need a matched product type relation $\matchedProd{\TMV}{\TMV_1}{\TMV_2}$.

The unmarked language is extended with a pair constructor $\EPair{\EMV}{\EMV}$ and projection
operators $\EProjL{\EMV}$ and $\EProjR{\EMV}$, governed by standard bidirectional rules. In addition
to the synthesis rules, an explicit analysis rules is defined for pairs: if the expected type has a matched product type (cf. matched arrow types above), the responsibility for type errors is shifted to the components.

We can devise the basic marking rules from the unmarked typing rules.
%
\begin{mathpar}
  \judgment{
    \ctxSynFixedInto{\ctx}{\EMV_1}{\ECMV_1}{\TMV_1} \\\\
    \ctxSynFixedInto{\ctx}{\EMV_2}{\ECMV_2}{\TMV_2}
  }{
    \ctxSynFixedInto{\ctx}{\EPair{\EMV_1}{\EMV_2}}{\ECPair{\ECMV_1}{\ECMV_2}}{\TProd{\TMV_1}{\TMV_2}}
  }{MKSPair}

  \judgment{
    \matchedProd{\TMV}{\TMV_1}{\TMV_2} \\
    \ctxAnaFixedInto{\ctx}{\EMV_1}{\ECMV_1}{\TMV_1} \\\\
    \ctxAnaFixedInto{\ctx}{\EMV_2}{\ECMV_2}{\TMV_2}
  }{
    \ctxAnaFixedInto{\ctx}{\EPair{\EMV_1}{\EMV_2}}{\ECPair{\ECMV_1}{\ECMV_2}}{\TMV}
  }{MKAPair1}

  \judgment{
    \ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV} \\\\
    \matchedProd{\TMV}{\TMV_1}{\TMV_2}
  }{
    \ctxSynFixedInto{\ctx}{\EProjL{\EMV}}{\ECProjL{\ECMV}}{\TMV_1}
  }{MKSProjL1}

  \judgment{
    \ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV} \\\\
    \matchedProd{\TMV}{\TMV_1}{\TMV_2}
  }{
    \ctxSynFixedInto{\ctx}{\EProjR{\EMV}}{\ECProjR{\ECMV}}{\TMV_2}
  }{MKSProjR1}
\end{mathpar}
However, as previously seen with lambda abstractions and applications, two sets of rules are further
necessary to satisfy totality. Firstly, the premise in \textsc{UAPair} that $\TMV$ is a matched
binary product may fail, requiring the introduction of a new error mark,
$\ECAnaNonMatchedProd{\ECMV}$, which is analogous to $\ECAnaNonMatchedArrow{\ECMV}$ for lambda
abstractions. Another kind of error may arise when the subject of a projection does not synthesize a
matched product type. As in our development of marking for applications, we utilize a new mark,
written $\ECSynNonMatchedProd{\ECMV}$. These cases give the final marking rules for products:
%
\begin{mathpar}
  \judgment{
    \notMatchedProd{\TMV} \\
    \ctxAnaFixedInto{\ctx}{\EMV_1}{\ECMV_1}{\TUnknown} \\
    \ctxAnaFixedInto{\ctx}{\EMV_2}{\ECMV_2}{\TUnknown}
  }{
    \ctxAnaFixedInto{\ctx}{\EPair{\EMV_1}{\EMV_2}}{\ECPairAnaNonMatchedProd{\ECMV_1}{\ECMV_2}}{\TMV}
  }{MKAPair2} \\

  \judgment{
    \ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV} \\
    \notMatchedProd{\TMV}
  }{
    \ctxSynFixedInto{\ctx}{\EProjL{\EMV}}{\ECProjLSynNonMatchedProd{\ECMV}}{\TMV_1}
  }{MKSProjL2}

  \judgment{
    \ctxSynFixedInto{\ctx}{\EMV}{\ECMV}{\TMV} \\
    \notMatchedProd{\TMV}
  }{
    \ctxSynFixedInto{\ctx}{\EProjR{\EMV}}{\ECProjRSynNonMatchedProd{\ECMV}}{\TMV_2}
  }{MKSProjR2}
\end{mathpar}

\input{let}




\subsection{Agda Mechanization}
\label{sec:calculus-agda}
% TODO clarify exactly what is/isn't mechanized

The semantics and metatheory presented above, including the extension with binary products, have
been fully mechanized in the Agda proof assistant. Though the mechanization's documentation contains
more detailed discussion regarding technical decisions made therein, we highlight some important
aspects here.

The standard approach of modeling judgments as inductive datatypes and rules as constructors for
those datatypes is taken. For marked expressions, we opt for implicitly typed terms,
which gives us part of \cref{thm:calculus-marking-well-formedness} for free. For the convenience of
readers interested in browsing the mechanization, all rule names match those presented here.

\subsection{Polymorphism and Richer Judgemental Structures}
\label{sec:calculus-poly}

The case studies above demonstrate that the judgemental structure of the marked lambda calculus is suitable to support a variety of extensions. We hope that this spurs language designers to designed mark variants of other calculi, following the recipe discussed above.

In calculi with richer judgemental structure---for example, System F, which introduces type validity and type variables \cite{tapl}---the general approach is again to define marks for any new kind of error that might arise, e.g. the appearance of a type with free type variables, and marking judgements corresponding to each judgement in the original language, e.g. here defining marking for types. One small subtlety in doing so is that a marked free variable might end up on the right side of the typing arrows. However, it is straightforward to treat a marked free variable simply as another form of unknown type for the purposes of type consistency and other operations. Type functions and type application operate much like standard functions and function application after this additional judgemental structure is accounted for.
We leave as future work the task of defining a marked version of even more elaborate bidirectional type systems, e.g. \citet{dunfield13}'s rather substantial formulation of implicit type application in a bidirectional setting (which would have to handle, for example, the situation where no implicit argument can be resolved).


\section{Integrating Marking with Editing}
\label{sec:calculus-structured-editing}
\subsection{Hazel Implementation}
\label{sec:calculus-hazel}

We have implemented a marking system based on the marked lambda calculus as the foundation for a new version of the Hazel language server. In particular, we have implemented marking for all of the features in the previous section as well as Hazel's $n$-tuples, lists, algebraic datatypes, general pattern matching \cite{oopsla23}, strings, and explicit polymorphism (all following the same recipe we developed above). Hazel is implemented in OCaml and compiles to Javascript via \li{js_of_ocaml} \cite{jsoo} for use in the browser. The supplemental material contains a pre-built implementation.

The result of this effort is the first full-scale typed functional language equipped with a language server that solves the semantic gap problem: all of Hazel's semantic services are available as long as the program sketch is syntactically well-formed, which include type hints \cite{potter1}, semantic navigation, semantic code completion \cite{potter1,blinn}, contextualized documentation \cite{potter2}, and, because Hazel is able to evaluate programs with empty and non-empty holes due to prior work \cite{HazelnutLive}, even semantic services that require run-time information, like live testing.
% 

Hazel offers both a textual syntax, with explicit empty holes, and more interestingly,
a structure editor that is able to additionally offer partial syntactic error recovery.
In particular, the \li{tylr} editor uses a form of structured syntax error recovery that automaticallys insert empty holes to maintain syntactic well-formedness as long as matching delimiters are placed by the user \cite{tylr}. Efforts outside of the scope of this paper are underway to define syntactic error recovery mechanisms that can handle unmatched delimiters as well, which would achieve total syntax error recovery. In combination with our contributions, this would achieve the Hazel project's stated goal of ensuring that \emph{there are no meaningless editor states}.


\subsection{Fixing Holes in Hazelnut}
\label{sec:calculus-hazelnut}

Earlier versions of Hazel achieved total syntax error recovery by using a term-based structure editor, which maintained delimiter matching by construction, albeit at the cost of some syntactic rigidity. The Hazelnut action calculus introduced by \citet{HazelnutPOPL} specifies such a structure editor formally. Notably, this calculus also supports a form of type error localization and recovery: edit actions can automatically insert non-empty holes around type inconsistencies that appear at the cursor after an edit action. This requires specifying a bidirectionally typed action calculus that propagates type and binding information to the cursor, given by the synthetic action judgment, written
$\ASEAction{\ctx}{\EMV}{\TMV}{\EMV'}{\TMV'}{\AMV}$, and the analytic action judgment, written
$\AAEAction{\ctx}{\EMV}{\EMV'}{\TMV}{\AMV}$.

A significant issue with Hazelnut is that it does not allow (i.e. it leaves undefined) actions that require \emph{non-local} mark (i.e. non-empty hole, in Hazelnut's parlance) insertion or removal. For
example, though the system can wrap an arbitrary expression in an arithmetic operation, it cannot
wrap an arbitrary expression $\EMV$ in a lambda abstraction, i.e. construct
$\ELam{x}{\TUnknown}{\EMV}$ directly from $\EMV$. The binding of $x$ with the unknown type may
shadow a previous declaration and require the removal of error holes in body. The calculus includes manual non-empty hole insertion and removal actions as a workaround.

The fundamental issue is that Hazelnut did not have a total marking system that it could deploy to remark expressions where needed. The marked lambda calculus allows us to solve this problem, in two different ways.

One approach is to define an untyped action calculus, \emph{wholly decoupling} edit actions from typing. Under this simplified design, the action calculus, given by the singular action
judgment, written $\AUEAction{\EMV}{\EMV'}{\AMV}$, is concerned only with the manipulation of
syntax, and the total marking procedure yields statically meaningful terms with error marks inserted at the appropriate positions as a kind of editor decoration. This solves the problem
outlined above; since marking operates on the entire program after each action, arbitrary
constructions are permitted.

Alternatively, instead of a wholly untyped action calculus, one may directly integrate re-marking logic into the typed Hazelnut
calculus, making use of the type and scoping information being propagated to re-mark only in scopes where it might be necessary. For example, we can wrap $\ECMV$ into
$\ECLam{x}{\TUnknown}{\ECMV}$ by re-mark the body under the context with $x$ binding
the unknown type:
\[%
  \judgment{
    \ctxSynFixedInto{\extendCtx{\ctx}{x}{\TUnknown}}{\erase{\ECMV}}{\ECMV'}{\TMV'}
  }{
    \ASEConLam{\ctx}{\ECMV}{\TMV}{\ECMV'}{\TMV'}{x}
  }{ASEConLam}
\]%
The
supplemental material contains a complete formal description of both variants, and the untyped
action semantics and related metatheory are mechanized in Agda. Because of the simplicity of the untyped version, and because marking is defined separately, this Agda mechanization can serve universally as a baseline for correctness of approaches, like our initial design that aim to make use of type and scope information, and perhaps other analyses, to minimize re-marking. We leave a complete assessment of this and other remarking optimization approaches to future work.
