\section{Related Work}
\label{sec:related}

The contributions of this paper build directly on the Hazelnut type system \cite{omar2017b}, which is discussed extensively throughout. Non-empty holes in Hazelnut generalize to marks in this work. In brief, we contribute a total marking procedure (Section~\ref{sec:calculus}) and type hole inference scheme (Section~\ref{sec:thi}) for a system based closely on Hazelnut, and use it to fix some expressiveness issues in Hazelnut's edit action calculus (Section~\ref{sec:calculus-structured-editing}). 

Hazelnut is in-turn rooted in gradual type theory \cite{siek2006, siek2015}. We make extensive use of (only) the static aspects of gradual typing---namely, the universal consistency of the unknown type---to enable recovery from marked errors, which can leave missing type information.

Our focus was exclusively on static typing in this paper, and the results are relevant to the design of language servers for any statically typed language, but it is worth noting that the results in this paper, taken together with Hazel's support for maintaining syntactic well-formedness using structure editing \cite{moon2023,moon2022} and for running programs with holes and marked errors \cite{omar2019}, allow our implementation of Hazel to achieve \emph{total liveness}: every editor state is syntactically, statically, and dynamically meaningful, without gaps.

Type error localization is a well-studied problem in practice. This paper is the first to formally support the intuition that, in the words of \citet{dunfield2019}, ``bidirectional typing improves error locality.'' Although there has been considerable folklore around error localization 
for systems with local type inference, the problem has received little formal attention. We hope that this paper, with its rigorous formulation
of type error localization and recovery for bidirectionally typed languages, will provide more rigorous grounding to language server development,
much as bidirectional typing has done for type checker development.

For systems rooted in constraint solving, there has been considerable work in improving error localization because such systems are notorious for making error localization difficult, and programmers are often confused by localization decisions \cite{wand1986} because they are rooted in \emph{ad hoc} traversal orders \cite{mcadam1999,lee1998}. 
More recently, there has been a series of papers that discuss finding the most likely location for an error based on maximum likelihood estimation \cite{zhang2014} or manual/learned weights \cite{pavlinovic2014,seidel2017}.
While improving the situation somewhat, these remain fundamentally \emph{ad hoc} in their need to guess intent. However, data-driven approaches could perhaps be layered atop type hole inference to improve the ranking or filtering of suggestions.

A more neutral alternative is to derive a set of terms that contribute to an error, an approach known as type error slicing \cite{haack2003,tip2001,schilling2011}. This creates a large amount of information for the programmer to consume. Our approach is to instead simply report the constraint inconsistencies on a hole in the program and allow for the programmer to interactively refine their intent, so only the bidirectional type system is responsible for identifying particular erroneous expressions. We do not make particular usability claims about the interactive affordances related to type hole inference in this paper, but rather simply claim a novel neutral point in the overall design space that uniquely combines local and global approaches.

Recent work on gradual liquid type inference described an exploratory interface for filling holes in refinement types by selecting from partial solutions to conflicting refinement type constraints \cite{vazou2018}. This is similar in spirit to type hole inference as described in this paper, albeit targeting program verification predicates.

The underlying unification algorithm is essentially standard---the novelty is in how the unification results are used and how failures are handled, rather than in the inference itself. In particular, we base our approach on the system described by \citet{siek2008}, because it also identifies type inference variables with the unknown type from gradual typing and the union find data structure is useful for computing possible type sets. \citet{garcia2015} similarly present a static implicitly typed language, where users opt into dynamism by annotating an expression with the gradual type "?", and an associated type inference algorithm and accompanying metatheory. By contrast, the Hazelnut type system assigns gradual types to programs that would ordinarily not type-check in a non-gradual system by wrapping them in expression holes. The type inference algorithm presented in \citet{garcia2015} also does not specify what to do if the constraint set cannot be solved. If a single static type cannot be determined for an expression, its type is simply undefined, whereas our approach provides a list of suggestions derived from any conflicting constraints if a single substitution cannot be determined. As our focus is on failure cases and partially consistent suggestions, the metatheory in this prior work is less relevant in guiding the design of the type hole inference system.

Of note, however, is that approaches that eagerly solve and substitute for type inference variables \cite{odersky1999,pottier2014,mcadam1999} are not well-suited to the type hole inference approach, as they lose information necessary for computing partially consistent suggestions. 

% In addition to type error localization and recovery, type hole inference touches on the problem of type error repair, as has been considered by other work \cite{lerner07}. We hope that our work will drive future work on rigorous repairs.

In the realm of error messages for constraint-based inference, work on the Helium Haskell compiler \cite{heeren2003} offers two constraint solvers based on the desired feedback: a global, type graph-based constraint solver which provides detailed error messages, and a lightweight and high-performance greedy solver. When using the global constraint solver, various heuristics can tune the likelihood of different parts of programs reported as error sources.
Recently, \citet{bhanuka2023} model the flow of type information throughout the program using subtyping constraints to produce detailed error messages when unification fails.
Our focus in this paper has not been on the error messages displayed on-screen, about which we make no specific claims.
It may, however, be beneficial to indicate to the user from where in the program type suggestions originated via type provenances. Documenting the flow of type information would require using asymmetric constraints rather than typical bidirectional equality constraints. 

In addition, there has been considerable work on improving explanations for type errors, e.g., by providing sample inputs (dynamic witnesses) that elicit runtime errors \cite{seidel2016}. With this approach, one can generate graphs for visualizing the execution of witnesses and heuristically identify the source of errors with around 70\% accuracy.
These and a variety of other approaches to explaining errors are a fruitful avenue for future integration into the system.
