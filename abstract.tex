\begin{abstract}
Type systems typically only define the conditions under which an expression is well-typed, leaving ill-typed expressions formally meaningless. This approach is insufficient for developing language servers for modern programming environments, which are expected to sensibly localize type errors and continue to provide a variety of semantic services in their presence. Lacking formal foundations, error localization has largely become a matter of folklore in the community. Recent work on the Hazelnut calculus takes a step toward assigning formal meaning to erroneous programs, but it stops short of a comprehensive account. In particular,  (1) Hazelnut is able to reason around marked type inconsistencies, but not several other kinds of static errors, and (2) Hazelnut provides an insufficient account of the marking procedure itself, relying on a limited structure editor, or on the user, to correctly insert marks.\todo{decenter Hazelnut?} This paper addresses these deficiencies, contributing the first comprehensive formal account of type error localization, called the marked lambda calculus. This contribution is independently useful as a core calculus for language servers. In addition, we deploy its total marking procedure to fix several instances of undefined behavior in the Hazelnut structure editor calculus, namely by allowing edits that introduce non-local errors. We mechanize the calculus in Agda and implement an extension in Hazel, a full-scale live functional programming environment previously based on Hazelnut.

The marked lambda calculus supports local type inference, i.e. it is bidirectionally typed. Constraint-based type inference schemes (e.g. Hindley-Milner) are notorious for complicating error localization. We approach the problem of  constraint-based type inference in a novel manner: we deploy constraint solving as a layer atop a gradual bidirectionally typed core, where it infers type hole fillings. This system is able to elegantly handle situations where the system of constraints cannot be solved, because the unification algorithm we develop localizes errors arising from inconsistent constraints to individual type holes, rather than attempting to localize them to one particular expression, which is fundamentally \emph{ad hoc}. The user can resolve these errors by selecting from suggested partial solutions, or leave the errors unresolved, in which case they operate as the unknown type from gradual typing. We formally specify this approach and implement it in Hazel. 
\end{abstract}
