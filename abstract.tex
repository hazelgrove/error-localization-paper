\begin{abstract}
Type systems typically only define the conditions under which an expression is well-typed, leaving ill-typed expressions entirely meaningless. 
This approach is insufficient as the basis for language servers for modern programming environments, which are expected to sensibly localize type errors and recover, i.e. continue to provide a variety of semantic services in their presence. 
This paper addresses this problem, contributing the first comprehensive formal account of type error localization and recovery, called the marked lambda calculus. This calculus, which is intended as a core calculus for language servers, consists of a gradual type system for expressions with marked errors and a total marking procedure on unmarked expressions with holes. We mechanize the metatheory of the marked lambda calculus in Agda, deploy its total marking procedure to fix several instances of undefined behavior in the Hazelnut structure editor calculus, and implement the system as the new basis for Hazel, a full-scale live functional programming environment.

The marked lambda calculus supports local type inference, i.e. it is bidirectionally typed. Constraint-based type inference schemes (e.g. Hindley-Milner) are notorious for complicating error localization. We approach the problem of incorporating constraint-based type inference by deploying constraint solving as a type hole filling layer atop a gradual bidirectionally typed core. When the system of constraints cannot be fully solved, the unification algorithm we develop localizes errors arising from inconsistent constraints to individual type holes, rather than attempting to localize them in an \emph{ad hoc} manner to one particular expression and then failing to recover from there. The user can resolve these errors by selecting from suggested partial solutions, or leave the errors unresolved, in which case the type hole recovers gradually. We formally specify this type hole inference system and implement it in Hazel. 
\end{abstract}

% Lacking formal foundations, error localization has largely become a matter of folklore in the community. 
% Recent work on the Hazelnut calculus takes a step toward assigning formal meaning to erroneous programs, but it stops short of a comprehensive account. 
% In particular,  (1) Hazelnut is able to reason around marked type inconsistencies, but not several other kinds of static errors, and (2) Hazelnut provides an insufficient account of the marking procedure itself, relying on a limited structure editor, or on the user, to correctly insert marks.\todo{decenter Hazelnut?} 
