\begin{abstract}
Type systems typically only define the conditions under which an expression is well-typed, leaving ill-typed expressions entirely meaningless. 
This approach is insufficient as the basis for language servers for modern programming environments, which are expected to sensibly localize any type errors and recover, i.e. continue to provide a variety of downstream semantic services. 
This paper addresses this problem, contributing the first comprehensive formal account of type error localization and recovery: the marked lambda calculus. In particular, we define a gradual type system for expressions with marked errors and holes, together with a total procedure for marking unmarked expressions. We mechanize the metatheory of the marked lambda calculus in Agda and implement it, scaled up, as the new basis for Hazel, a full-scale live functional programming environment. 
As a secondary contribution, we show how total marking resolves 
the problem of undefined behavior in the Hazelnut structure editor calculus
(though marking itself does not require a structure editor).

The marked lambda calculus supports local type inference, i.e. it is bidirectionally typed. Constraint-based type inference notoriously complicates error localization and recovery. We approach this problem by deploying constraint solving as a type-hole-filling layer atop our gradual bidirectionally typed core. The unification algorithm we contribute localizes errors arising from inconsistent constraints to type holes with traced  provenances, rather than attempting to localize them in an \emph{ad hoc} manner to particular expressions. The user can choose how to shift these errors to expressions by selecting from suggested partial solutions, or allow the unresolved type holes to recover gradually. We implement this type hole inference system in Hazel. 
\end{abstract}

% Lacking formal foundations, error localization has largely become a matter of folklore in the community. 
% Recent work on the Hazelnut calculus takes a step toward assigning formal meaning to erroneous programs, but it stops short of a comprehensive account. 
% In particular,  (1) Hazelnut is able to reason around marked type inconsistencies, but not several other kinds of static errors, and (2) Hazelnut provides an insufficient account of the marking procedure itself, relying on a limited structure editor, or on the user, to correctly insert marks.\todo{decenter Hazelnut?} 
