\subsection{Let with Composite Patterns}
\label{sec:calculus-let}

%TODO(andrew): justification, examples

In a traditional bidirectional presentation (CITE), let expressions without composite patterns usually have two rules: A type-annotated version which places the definition in analytic position, and an unannotated synthetic version. With composite patterns, this straightforward division is no longer possible, as whether or not there are type constraints on the definition depends on the (arbitrarily nested) sub-components of the pattern.
The most obvious approach is to instead use a single rule which synthesizes a type from the pattern, then analyzes the definition against that type. However, this runs afoul of user expectation. Consider the expression $\ELet{(a,b)}{(1,2)}{...}$. The semantics of pattern matching are often (CITE) given by expansion to nested lets under appropriate projections, beta-reduced as far as possible. Here this would give $\ELet{a}{1}{\ELet{b}{2}{...}}$. Notice that in the un-expanded expression, $1$ and $2$ are in analytic against the unknown type, whereas in the latter, they are in synthetic position.
At this point one should ask: Is there a meaningful difference between these two situations? There is at least a subtle semantic distinction: Synthetic means 'no type constraints', whereas analytic against unknown imposes a trivial type constraint.
This distinction behaviorally manifests in the case of expressions which can have internal type inconsistencies. As per the previous section on booleans, in the expression $\ELet{a}{\EIf{\ETrue}{1}{\EFalse}}{...}$, the conditional will be marked with an inconsistent branches error if in synthetic position, but if analyzed against unknown---with which both branches are consistent---no mark will be placed.
This raises the question: Do we need this distinction? Perhaps we can simply erase it, for example adding a rule to switch to synthetic mode whenever we analyze against hole, or vice-versa. This is similar to the path we take, but simply collapsing the distinction removes an important expressive dimension of user intent in gradual typing.
To better illustrate, we additionally add a compositional pattern annotation form, which can be applied to sub-patterns: $\ELet{(a, b:\TUnknown)}{(\EIf{\ETrue}{1}{\EFalse},\EIf{\ETrue}{1}{\EFalse})}{...}$. Here, we annotate the sub-pattern $b$ with an unknown type annotation. Here, the user is expressing their intent that the corresponding sub-definition should have some definite, as-yet unspecified, type. It is reasonable that the conditional should no longer be marked, as this action passes the buck, attribution-wise, to the annotation. However, it is also reasonable that the annotated unknown type itself should be considered in an error state, since there are no possible fillings for this hole. Indeed, precisely this will be accomplished in section 4.


We augment our type system with a new variant on the unknown type which can trigger a swtich from analysis to synthesis. The new type $\TUnknownSwitch$ behaves identically to $\TUnknown$ with respect to type consistency, the marched arrow and product judgements, and the join metafunction:
%
\[\begin{array}{rrcl}
  \TMName  & \TMV  & \Coloneqq & \cdots \mid \TUnknownSwitch
\end{array}\]

The unmarked language is extended by let expressions with composite patterns:
%
\[\begin{array}{rrcl}
  \EMName & \EMV & \Coloneqq & \cdots
                               \mid \ELet{\PMV}{\EMV}{\EMV} \\
  \PMName & \PMV & \Coloneqq & x 
                               \mid \_
                               \mid (p_1, p_2)
                               \mid p : \TMV \\
  \PCMName & \PCMV & \Coloneqq & x 
                               \mid \_
                               \mid (p_1, p_2)
                               \mid p : \TMV
                               \mid \ECInconType{\PCMV}
                               \mid \ECInconMatchedPair{\PCMV}
\end{array}\]
%
Let expressions are typed according to the following $\mathtt{USLet}$ and $\mathtt{UALet}$ rules. Additionally, we add a rule governing the switch from analysis to synthesis, triggered by analysis against the new Unknown-SynSwitch type:
\begin{mathpar}
\judgment{
     \ctxSynPat{\ctx}{\PMV}{\TMV_p}
     \\
     \ctxAnaType{\ctx}{\EMV_{def}}{\TMV_p}
     \\
     \ctxSynType{\ctx}{\EMV_{def}}{\TMV_{def}}
     \\\\
     \ctxAnaPat{\ctx}{\PMV}{\TMV_{def}}{\ctx_{b}}
     \\
     \ctxSynOrAnaType{\ctx_{b}}{\EMV_{b}}{\TMV}
   }{
     \ctxSynOrAnaType{\ctx}{\ELet{\PMV}{\EMV_{def}}{\EMV_{b}}}{\TMV}
   }{U(S/A)Let}
   
   \judgment{
     \ctxSynType{\ctx}{\EMV}{\_}
   }{
     \ctxAnaType{\ctx}{\EMV}{\TUnknownSwitch}
   }{SynSwitch}
    %\judgment{
    % \ctxSynPat{\ctx}{\PMV}{\TMV_p}
    % \\
    % \ctxAnaType{\ctx}{\EMV_{def}}{\TMV_p}
    % \\
    % \ctxSynType{\ctx}{\EMV_{def}}{\TMV_{def}}
    % \\\\
    % \ctxAnaPat{\ctx}{\PMV}{\TMV_{def}}{\ctx_{b}}
    % \\
    % \ctxSynType{\ctx_{b}}{\EMV_{b}}{\TMV}
   %}{
   %  \ctxSynType{\ctx}{\ELet{\PMV}{\EMV_{def}}{\EMV_{b}}}{\TMV}
   %}{USLet}
   %\\
   %\judgment{
   %  \ctxSynPat{\ctx}{\PMV}{\TMV_p}
   %  \\
   %  \ctxAnaType{\ctx}{\EMV_{def}}{\TMV_p}
   %  \\
   %  \ctxSynType{\ctx}{\EMV_{def}}{\TMV_{def}}
   %  \\\\
   %  \ctxAnaPat{\ctx}{\PMV}{\TMV_{def}}{\ctx_{b}}
   %  \\
   %  \ctxAnaType{\ctx_{b}}{\EMV_{b}}{\TMV}
   %}{
   %  \ctxAnaType{\ctx}{\ELet{\PMV}{\EMV_{def}}{\EMV_{b}}}{\TMV}
   %}{UALet}
\end{mathpar}
Finally, pattern synthesis and analysis are governed by the following rules. Note how variables and wildcards synthesize the Unknown-SynSwitch type, but note also that this type is never added to the context:

\begin{figure}[htbp]
  \raggedright
  \judgbox{\ensuremath{\ctxSynPat{\Gamma}{\PMV}{\TMV}}} Pattern $\PMV$ synthesizes type $\TMV$
  %
  \begin{mathpar}
   \judgment{ }{\ctxSynPat{\ctx}{\_}{\TUnknownSwitch}}{USPatWild}
   
   \judgment{ }{\ctxSynPat{\ctx}{x}{\TUnknownSwitch}}{USPatVar}
   
   %\judgment{ }{\ctxSynPat{\Gamma}{\hehole{}}{\TUnknownSwitch}}{USPatHole}
   \judgment{
     \ctxAnaPat{\ctx}{\PMV{}}{\tau}{\_}
   }{
        \ctxSynPat{\ctx}{\PMV : \tau}{}{\tau}
    }{USPatAnn}

   \judgment{
     \ctxSynPat{\ctx}{\PMV_1}{\TMV_1} \\
     \ctxSynPat{\ctx}{\PMV_2}{\TMV_2}
   }{
     \ctxSynPat{\ctx}{\EPair{\PMV_1}{\PMV_2}}{\TPair{\TMV_1}{\TMV_2}}
   }{USPatPair}
  \end{mathpar}
  %
  \label{fig:calculus-pattern-synthesis}
\end{figure}


\begin{figure}[htbp]
  \raggedright
  \judgbox{\ensuremath{\ctxAnaPat{\ctx_{in}}{\PMV}{\TMV}{\ctx_{out}}}} Pattern $\PMV$ analyzes against type $\TMV$ producing context $\Gamma_{out}$
  %
  \begin{mathpar}
   \judgment{ }{\ctxAnaPat{\ctx}{\_}{\TMV}{\ctx}}{UAPatWild}
   
   \judgment{ }{\ctxAnaPat{\Gamma}{x}{\TMV}{\ctx, x:\TMV}}{UAPatVar}
   
   %\judgment{ }{\ctxAnaPat{\ctx}{\hehole{}}{\tau}}{UAPatHole}{\ctx}
   \judgment{
     \ctxAnaPat{\ctx}{\PMV{}}{\tau'}{\ctx'}
     \\
     \consistent{\tau}{\tau'}
   }{
        \ctxAnaPat{\ctx}{\PMV : \tau'}{\tau}{\ctx'}
    }{UAPatAnn}

   \judgment{
      \matchedPair{\TMV}{\TMV_1}{\TMV_2} \\\\
      \ctxAnaPat{\ctx}{\PMV_1}{\TMV_1}{\ctx_1} \\\\
      \ctxAnaPat{\ctx_1}{\PMV_2}{\TMV_2}{\ctx_2}
    }{
      \ctxAnaPat{\ctx}{\ECPair{\PMV_1}{\PMV_2}}{\TMV}{\ctx_2}
    }{UAPatPair}
  \end{mathpar}
  %
  \label{fig:calculus-pattern-analysis}
\end{figure}


\begin{figure}[htbp]
  \raggedright
  \begin{mathpar}

   \judgment{ }{\ctxSynFixedInto{\ctx}{\_}{\_}{\TUnknownSwitch}}{ISPatWild}
   
   \judgment{ }{\ctxSynFixedInto{\ctx}{x}{x}{\TUnknownSwitch}}{ISPatVar}

   \judgment{
     \ctxSynFixedInto{\ctx}{\PMV_1}{\PCMV_1}{\TMV_1} \\\\
     \ctxSynFixedInto{\ctx}{\PMV_2}{\PCMV_2}{\TMV_2}
   }{
      \ctxSynFixedInto{\ctx}{\EPair{\PMV_1}{\PMV_2}}{\ECPair{\PCMV_1}{\PCMV_2}}{\TPair{\TMV_1}{\TMV_2}}
   }{ISPatPair}
   
   \judgment{
     \ctxAnaPat{\ctx}{\PMV{}}{\TMV}{\_} \\
     \ctxAnaFixedIntoPat{\ctx}{\PMV}{\PCMV}{\TMV}{\_}
   }{
        \ctxSynFixedInto{\ctx}{\PMV : \tau}{\PCMV : \tau}{\tau}
    }{ISPatAnn}

   \judgment{
     \ctxNotAnaPat{\ctx}{\PMV{}}{\TMV}{\_} \\
     \ctxAnaFixedIntoPat{\ctx}{\PMV}{\PCMV}{\TUnknown}{\_}
   }{
        \ctxSynFixedInto{\ctx}{\PMV : \TMV}{\ECInconType{\PCMV} : \TMV}{\TMV}
    }{ISPatAnnFail}
   \\\\
   \judgment{ }{\ctxAnaFixedIntoPat{\ctx}{\_}{\_}{\TMV}{\ctx}}{IAPatWild}
   
   \judgment{ }{\ctxAnaFixedIntoPat{\ctx}{x}{x}{\TMV}{\ctx, x:\TMV}}{IAPatVar}
   \\\\
   \judgment{
     \matchedPair{\TMV}{\TMV_1}{\TMV_2} \\\\
     \ctxAnaFixedIntoPat{\ctx}{\PMV_1}{\PCMV_1}{\TMV_1}{\ctx_1} \\\\
     \ctxAnaFixedIntoPat{\ctx_1}{\PMV_2}{\PCMV_2}{\TMV_2}{\ctx_2}
   }{
      \ctxAnaFixedIntoPat{\ctx}{\EPair{\PMV_1}{\PMV_2}}{\ECPair{\PCMV_1}{\PCMV_2}}{\TMV}{\ctx_2}
   }{IAPatPair}

   \judgment{
     \notMatchedPair{\TMV} \\\\
     \ctxAnaFixedIntoPat{\ctx}{\PMV_1}{\PCMV_1}{\TUnknown}{\ctx_1} \\\\
     \ctxAnaFixedIntoPat{\ctx_1}{\PMV_2}{\PCMV_2}{\TUnknown}{\ctx_2}
   }{
      \ctxAnaFixedIntoPat{\ctx}{\EPair{\PMV_1}{\PMV_2}}{\ECInconMatchedPair{\ECPair{\PCMV_1}{\PCMV_2}}}{\TMV}{\ctx_2}
   }{IAPatPairFail}

   \judgment{
     \ctxAnaPat{\ctx}{\PMV{}}{\tau'}{\ctx'} \\
     \consistent{\tau}{\tau'} \\
     \ctxAnaFixedIntoPat{\ctx}{\PMV}{\PCMV}{\tau'}{\_}
   }{
        \ctxAnaFixedIntoPat{\ctx}{\PMV : \tau'}{\PCMV : \tau'}{\tau}{\ctx'}
   }{IAPatAnn}

   \judgment{
     \ctxNotAnaPat{\ctx}{\PMV{}}{\tau}{\ctx'} \\
     \ctxAnaFixedIntoPat{\ctx}{\PMV}{\PCMV}{\tau}{\_}
   }{
        \ctxAnaFixedIntoPat{\ctx}{\PMV : \tau'}{\ECInconType{\PCMV} : \tau'}{\tau}{\ctx'}
   }{IAPatAnnFail1}

   \judgment{
     \ctxNotAnaPat{\ctx}{\PMV{}}{\tau}{\ctx'} \\
     \ctxAnaFixedIntoPat{\ctx}{\PMV}{\PCMV}{\tau}{\_}
   }{
        \ctxAnaFixedIntoPat{\ctx}{\PMV : \tau}{\ECInconType{\PCMV} : \tau}{\tau}{\ctx'}
   }{IAPatAnnFail2}
  \end{mathpar}
  %
  \caption{Pattern Marking}
  \label{fig:calculus-pattern-synthesis-marking}
\end{figure}

\begin{figure}[htbp]
  \begin{mathpar}

   \judgment{ }{\ctxSynPat{\ctx}{\_}{\TUnknownSwitch}}{MSPatWild}
   
   \judgment{ }{\ctxSynPat{\ctx}{x}{\TUnknownSwitch}}{MSPatVar}
   
   \judgment{
     \ctxAnaPat{\ctx}{\PCMV{}}{\tau}{\_}
   }{
        \ctxSynPat{\ctx}{\PCMV : \tau}{}{\tau}
    }{MSPatAnn}

   \judgment{
     \ctxSynPat{\ctx}{\PCMV_1}{\TMV_1} \\
     \ctxSynPat{\ctx}{\PCMV_2}{\TMV_2}
   }{
     \ctxSynPat{\ctx}{\EPair{\PCMV_1}{\PCMV_2}}{\TPair{\TMV_1}{\TMV_2}}
   }{MSPatPair}
  \end{mathpar}
  %
  \caption{Marked Pattern Synthesis}
  \label{fig:calculus-pattern-synthesis-marked}
\end{figure}

\begin{figure}[htbp]
  \raggedright
  \begin{mathpar}
   \judgment{ }{\ctxAnaPat{\ctx}{\_}{\TMV}{\ctx}}{MAPatWild}
   
   \judgment{ }{\ctxAnaPat{\Gamma}{x}{\TMV}{\ctx, x:\TMV}}{MAPatVar}
   \\\\
   \judgment{
     \ctxAnaPat{\ctx}{\PCMV{}}{\tau'}{\ctx'}
     \\
     \consistent{\tau}{\tau'}
   }{
        \ctxAnaPat{\ctx}{\PCMV : \tau'}{\tau}{\ctx'}
    }{MAPatAnn}

    \judgment{
     \ctxAnaPat{\ctx}{\PCMV{}}{\tau'}{\ctx'}
     \\
     \inconsistent{\tau}{\tau'}
   }{
        \ctxAnaPat{\ctx}{\ECInconType{\PCMV} : \tau'}{\tau}{\ctx'}
    }{MAPatAnnFail}
   \\\\
   \judgment{
      \matchedPair{\TMV}{\TMV_1}{\TMV_2} \\\\
      \ctxAnaPat{\ctx}{\PCMV_1}{\TMV_1}{\ctx_1} \\\\
      \ctxAnaPat{\ctx_1}{\PCMV_2}{\TMV_2}{\ctx_2}
    }{
      \ctxAnaPat{\ctx}{\ECPair{\PCMV_1}{\PCMV_2}}{\TMV}{\ctx_2}
    }{MAPatPair}
  \end{mathpar}
  %
  \caption{Marked Pattern Analysis}
  \label{fig:calculus-pattern-analysis-marked}
\end{figure}